<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="application-name" content="Boggle">
  <meta name="apple-mobile-web-app-title" content="Boggle">
  <link rel="icon" type="image/svg+xml" href="icon.svg">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@600;700;800&display=swap" rel="stylesheet">
  <title>Daily Boggle</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>tailwind.config = { corePlugins: { preflight: true } }</script>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <style>
    * { -webkit-tap-highlight-color: transparent; font-family: 'Nunito', sans-serif; box-sizing: border-box; }
    html {
      overflow-x: hidden;
      overflow-y: auto;
    }
    body {
      min-height: 100vh;
      min-height: -webkit-fill-available;
      overflow-x: hidden;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior-x: none;
    }
    #app {
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
      min-height: 100vh;
      padding-bottom: 20px;
    }
    .tile { touch-action: none; user-select: none; -webkit-user-select: none; cursor: pointer; will-change: transform, background-color; }
    .tile-pop { animation: pop 0.15s ease-out; }
    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1.1); } }
    .tile-shake { animation: shake 0.4s ease-out; }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
    .tile-bounce { animation: bounce 0.5s ease-out; }
    @keyframes bounce { 0% { transform: scale(1); background: #4ade80; } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
    .float-points { position: fixed; animation: floatUp 1.5s ease-out forwards; pointer-events: none; font-weight: 800; font-size: 2.5rem; color: #fef08a; text-shadow: 0 0 10px #facc15, 0 0 20px #facc15, 0 3px 6px rgba(0,0,0,0.9); z-index: 1000; }
    @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(1.2); } 20% { opacity: 1; transform: translateY(-20px) scale(1.3); } 100% { opacity: 0; transform: translateY(-100px) scale(1.5); } }
    .timer-urgent { animation: pulse 0.5s ease-in-out infinite; color: #fca5a5 !important; }
    @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.05); } }
    .board-container { position: relative; }
    .swipe-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
    .swipe-line { stroke: rgba(250, 204, 21, 0.9); stroke-width: 6; stroke-linecap: round; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3)); }
    button { -webkit-appearance: none; appearance: none; }
    input { -webkit-appearance: none; appearance: none; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-b from-blue-600 to-green-600">
  <div id="app"></div>

  <script src="words.js"></script>
  <script>
    // ============================================
    // FIREBASE CONFIGURATION
    // ============================================
    const firebaseConfig = {
      apiKey: "AIzaSyD2EquXAFa4_6VsTs2MbarcAtVwbKWaS4Q",
      authDomain: "daily-trivia-75954.firebaseapp.com",
      databaseURL: "https://daily-trivia-75954-default-rtdb.firebaseio.com",
      projectId: "daily-trivia-75954",
      storageBucket: "daily-trivia-75954.firebasestorage.app",
      messagingSenderId: "146196428161",
      appId: "1:146196428161:web:2e479bea4d6e5383c6e480"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    // ============================================

    // Boggle dice
    const BOGGLE_DICE = [
      'AAEEGN', 'ABBJOO', 'ACHOPS', 'AFFKPS',
      'AOOTTW', 'CIMOTU', 'DEILRX', 'DELRVY',
      'DISTTY', 'EEGHNW', 'EEINSU', 'EHRTVW',
      'EIOSST', 'ELRTTY', 'HIMNQU', 'HLNNRZ'
    ];

    // Seeded random
    function seededRandom(seed) {
      const x = Math.sin(seed++) * 10000;
      return x - Math.floor(x);
    }

    // Generate daily board
    function generateDailyBoard(dateString) {
      const seed = dateString.split('-').join('') * 1;
      let currentSeed = seed;
      const shuffledDice = [...BOGGLE_DICE];
      for (let i = shuffledDice.length - 1; i > 0; i--) {
        const j = Math.floor(seededRandom(currentSeed++) * (i + 1));
        [shuffledDice[i], shuffledDice[j]] = [shuffledDice[j], shuffledDice[i]];
      }
      return shuffledDice.map(die => {
        const faceIndex = Math.floor(seededRandom(currentSeed++) * 6);
        let letter = die[faceIndex];
        return letter === 'Q' ? 'Qu' : letter;
      });
    }

    // Generate board from seed (for practice mode sharing)
    function generateSeededBoard(seed) {
      let currentSeed = seed;
      const shuffledDice = [...BOGGLE_DICE];
      for (let i = shuffledDice.length - 1; i > 0; i--) {
        const j = Math.floor(seededRandom(currentSeed++) * (i + 1));
        [shuffledDice[i], shuffledDice[j]] = [shuffledDice[j], shuffledDice[i]];
      }
      return shuffledDice.map(die => {
        const faceIndex = Math.floor(seededRandom(currentSeed++) * 6);
        let letter = die[faceIndex];
        return letter === 'Q' ? 'Qu' : letter;
      });
    }

    // Generate random 5-digit code
    function generatePracticeCode() {
      return Math.floor(10000 + Math.random() * 90000);
    }

    // Validate board meets quality criteria
    function validateBoard(board) {
      // Count vowels (A, E, I, O, U)
      const vowels = 'AEIOU';
      let vowelCount = 0;
      const letterCounts = {};

      board.forEach(letter => {
        const l = letter.toUpperCase().charAt(0);
        if (vowels.includes(l)) vowelCount++;
        letterCounts[l] = (letterCounts[l] || 0) + 1;
      });

      // Check minimum 4 vowels
      if (vowelCount < 4) return false;

      // Check no more than 2 duplicate letters (letters appearing 2+ times)
      let duplicateCount = 0;
      for (const count of Object.values(letterCounts)) {
        if (count >= 2) duplicateCount++;
      }
      if (duplicateCount > 2) return false;

      return true;
    }

    // Generate random board (for practice mode)
    function generateRandomBoard() {
      let code, board;
      let attempts = 0;
      const maxAttempts = 100;

      do {
        code = generatePracticeCode();
        board = generateSeededBoard(code);
        attempts++;
      } while (!validateBoard(board) && attempts < maxAttempts);

      state.practiceCode = code;
      return board;
    }

    // Get today's date (local timezone - puzzle resets at local midnight)
    function getTodayString() {
      const now = new Date();
      return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
    }

    // Check adjacency
    function areAdjacent(pos1, pos2) {
      const row1 = Math.floor(pos1 / 4), col1 = pos1 % 4;
      const row2 = Math.floor(pos2 / 4), col2 = pos2 % 4;
      return Math.abs(row1 - row2) <= 1 && Math.abs(col1 - col2) <= 1 && pos1 !== pos2;
    }

    // Check if word can be formed
    function canFormWord(word, board) {
      const upperWord = word.toUpperCase();
      const boardUpper = board.map(l => l.toUpperCase());
      
      function search(wordIndex, position, used) {
        if (wordIndex >= upperWord.length) return true;
        const remaining = upperWord.slice(wordIndex);
        const letter = boardUpper[position];
        if (!remaining.startsWith(letter)) return false;
        const newUsed = new Set(used);
        newUsed.add(position);
        const nextIndex = wordIndex + letter.length;
        if (nextIndex >= upperWord.length) return true;
        for (let next = 0; next < 16; next++) {
          if (!newUsed.has(next) && areAdjacent(position, next)) {
            if (search(nextIndex, next, newUsed)) return true;
          }
        }
        return false;
      }
      
      for (let start = 0; start < 16; start++) {
        if (search(0, start, new Set())) return true;
      }
      return false;
    }

    // Score calculation
    function getWordScore(word) {
      const len = word.replace(/qu/gi, 'Q').length;
      if (len <= 2) return 0;
      if (len <= 4) return 1;
      if (len === 5) return 2;
      if (len === 6) return 3;
      if (len === 7) return 5;
      return 11;
    }

    
    // Show floating points animation
    function showFloatingPoints(points, x, y) {
      const el = document.createElement('div');
      el.className = 'float-points';
      el.textContent = '+' + points;
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1200);
    }

    // Animate tiles
    function animateTiles(indices, animClass) {
      indices.forEach(i => {
        const tile = document.querySelector('[data-index="' + i + '"]');
        if (tile) {
          tile.classList.remove('tile-pop', 'tile-shake', 'tile-bounce');
          void tile.offsetWidth; // trigger reflow
          tile.classList.add(animClass);
          setTimeout(() => tile.classList.remove(animClass), 500);
        }
      });
    }

    // Get tile center position
    function getTileCenter(index) {
      const tile = document.querySelector('[data-index="' + index + '"]');
      if (!tile) return { x: 0, y: 0 };
      const rect = tile.getBoundingClientRect();
      return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
    }

    // Dictionary loaded from words.js

    // Game state
    let state = {
      gameState: 'login', // login, ready, playing, finished
      board: [],
      selectedPath: [],
      currentWord: '',
      foundWords: [],
      timeLeft: 180,
      score: 0,
      message: '',
      todayDate: getTodayString(),
      playerName: localStorage.getItem('boggle_player') || '',
      inputMode: 'swipe',
      typedWord: '',
      isDragging: false,
      leaderboard: [],
      timerInterval: null,
      lastTouchTime: 0,
      lastTouchX: 0,
      lastTouchY: 0,
      pendingTile: null,
      pendingTimeout: null,
      possibleWords: null,
      practiceMode: false,
      practiceCode: null,
      // Multiplayer
      multiplayerMode: false,
      roomId: null,
      isHost: false,
      roomPlayers: [],
      roomStatus: null,
      mpResults: null,
      mpStartTime: null,
      mpSubmitted: false,
      countdownInterval: null
    };

    // Initialize board
    state.board = generateDailyBoard(state.todayDate);

    // Tile refs
    let tileElements = [];

    // API calls - Firebase
    async function checkPlayer(name) {
      try {
        const snapshot = await db.ref(`boggle/daily/${state.todayDate}/players/${name}`).once('value');
        if (snapshot.exists()) {
          const data = snapshot.val();
          return { played: true, score: data.score, words: data.wordCount };
        }
        return { played: false };
      } catch (e) {
        console.error('Firebase error:', e);
        return { played: false };
      }
    }

    async function saveScore(name, score, wordCount) {
      try {
        const playerRef = db.ref(`boggle/daily/${state.todayDate}/players/${name}`);

        // Check if already exists (prevent overwrites)
        const existing = await playerRef.once('value');
        if (existing.exists()) {
          console.log('Score already saved');
          return;
        }

        await playerRef.set({
          score: score,
          wordCount: wordCount,
          playedAt: firebase.database.ServerValue.TIMESTAMP
        });
      } catch (e) {
        console.error('Firebase error:', e);
      }
    }

    async function getLeaderboard() {
      try {
        const snapshot = await db.ref(`boggle/daily/${state.todayDate}/players`).once('value');
        if (!snapshot.exists()) return [];

        const players = [];
        snapshot.forEach(child => {
          players.push({
            player: child.key,
            score: child.val().score,
            words: child.val().wordCount
          });
        });

        // Sort by score descending
        players.sort((a, b) => b.score - a.score);
        return players;
      } catch (e) {
        console.error('Firebase error:', e);
        return [];
      }
    }

    // ============================================
    // MULTIPLAYER API FUNCTIONS - Firebase
    // ============================================

    let roomListener = null;

    async function mpCreateRoom(player, boardCode) {
      try {
        // Clean up old rooms first
        await cleanupOldRooms();

        // Generate unique 5-digit room ID
        let roomId;
        let attempts = 0;
        do {
          roomId = String(Math.floor(10000 + Math.random() * 90000));
          const exists = await db.ref(`boggle/rooms/${roomId}`).once('value');
          if (!exists.exists()) break;
          attempts++;
        } while (attempts < 10);

        if (attempts >= 10) {
          return { error: 'Could not generate room ID' };
        }

        const roomData = {
          boardCode: boardCode,
          host: player,
          status: 'waiting',
          createdAt: firebase.database.ServerValue.TIMESTAMP,
          players: {
            [player]: {
              joinedAt: firebase.database.ServerValue.TIMESTAMP,
              submitted: false
            }
          }
        };

        await db.ref(`boggle/rooms/${roomId}`).set(roomData);

        return { roomId: roomId, boardCode: boardCode };
      } catch (e) {
        console.error('Firebase error:', e);
        return { error: 'Network error' };
      }
    }

    async function mpJoinRoom(roomId, player) {
      try {
        const roomRef = db.ref(`boggle/rooms/${roomId}`);
        const snapshot = await roomRef.once('value');

        if (!snapshot.exists()) {
          return { error: 'Room not found' };
        }

        const room = snapshot.val();

        if (room.status !== 'waiting') {
          return { error: 'Game already started' };
        }

        const playerCount = Object.keys(room.players || {}).length;
        if (playerCount >= 8) {
          return { error: 'Room is full' };
        }

        // Add player to room
        await roomRef.child(`players/${player}`).set({
          joinedAt: firebase.database.ServerValue.TIMESTAMP,
          submitted: false
        });

        // Get updated player list
        const updatedSnapshot = await roomRef.child('players').once('value');
        const players = Object.keys(updatedSnapshot.val() || {});

        return {
          boardCode: room.boardCode,
          players: players
        };
      } catch (e) {
        console.error('Firebase error:', e);
        return { error: 'Network error' };
      }
    }

    async function mpStartRoom(roomId) {
      try {
        const roomRef = db.ref(`boggle/rooms/${roomId}`);

        // Get server time offset for accurate timing
        const serverTimeRef = db.ref('.info/serverTimeOffset');
        const offsetSnapshot = await serverTimeRef.once('value');
        const offset = offsetSnapshot.val() || 0;
        const serverTime = Date.now() + offset;
        const startTime = serverTime + 5000; // 5 seconds from now

        await roomRef.update({
          status: 'playing',
          startTime: startTime
        });

        return { success: true, startTime: startTime };
      } catch (e) {
        console.error('Firebase error:', e);
        return { error: 'Network error' };
      }
    }

    async function mpSubmitWords(roomId, player, words) {
      try {
        const playerRef = db.ref(`boggle/rooms/${roomId}/players/${player}`);

        await playerRef.update({
          words: words.join(','),
          submitted: true
        });

        // Check if all players have submitted
        const roomSnapshot = await db.ref(`boggle/rooms/${roomId}`).once('value');
        const room = roomSnapshot.val();
        const players = Object.values(room.players || {});
        const allSubmitted = players.every(p => p.submitted);

        if (allSubmitted) {
          await calculateAndSetResults(roomId);
        }

        return { success: true };
      } catch (e) {
        console.error('Firebase error:', e);
        return { error: 'Network error' };
      }
    }

    async function mpGetResults(roomId) {
      try {
        const snapshot = await db.ref(`boggle/rooms/${roomId}`).once('value');

        if (!snapshot.exists()) {
          return { error: 'Room not found' };
        }

        const room = snapshot.val();

        if (room.results) {
          return room.results;
        }

        // Results not ready yet - calculate them
        await calculateAndSetResults(roomId);
        const updatedSnapshot = await db.ref(`boggle/rooms/${roomId}/results`).once('value');
        return updatedSnapshot.val() || { error: 'Results not available' };
      } catch (e) {
        console.error('Firebase error:', e);
        return { error: 'Network error' };
      }
    }

    async function mpLeaveRoom(roomId, player) {
      try {
        stopRoomListener();

        const roomRef = db.ref(`boggle/rooms/${roomId}`);
        const snapshot = await roomRef.once('value');

        if (!snapshot.exists()) return;

        const room = snapshot.val();

        // If host is leaving, delete the room
        if (room.host === player) {
          await roomRef.remove();
        } else {
          // Just remove the player
          await roomRef.child(`players/${player}`).remove();
        }
      } catch (e) {
        console.error('Firebase error:', e);
      }
    }

    // ============================================
    // FIREBASE REAL-TIME LISTENER
    // ============================================

    function startRoomListener() {
      if (roomListener) stopRoomListener();

      const roomRef = db.ref(`boggle/rooms/${state.roomId}`);

      roomListener = roomRef.on('value', (snapshot) => {
        if (!snapshot.exists()) {
          // Room was deleted
          showMessage('Room closed');
          resetMultiplayerState();
          state.gameState = 'login';
          render();
          return;
        }

        const room = snapshot.val();
        const players = Object.keys(room.players || {});
        const playersChanged = JSON.stringify(state.roomPlayers) !== JSON.stringify(players);

        state.roomPlayers = players;
        state.roomStatus = room.status;

        // Handle state transitions
        if (room.status === 'playing' && state.gameState === 'mp-lobby') {
          state.mpStartTime = room.startTime;
          startMultiplayerGame(room.startTime);
          return;
        }

        if (room.status === 'finished' && (state.gameState === 'mp-waiting' || state.gameState === 'mp-playing')) {
          console.log('Room finished, fetching results...');
          stopRoomListener();
          fetchResults();
          return;
        }

        // Handle room reset for new game (non-host players)
        if (room.status === 'waiting' && state.gameState === 'mp-results') {
          console.log('Room reset for new game...');
          state.board = generateSeededBoard(room.boardCode);
          state.practiceCode = room.boardCode;
          state.foundWords = [];
          state.score = 0;
          state.mpSubmitted = false;
          state.mpResults = null;
          state.gameState = 'mp-lobby';
          render();
          return;
        }

        // Update UI for player changes in lobby
        if (playersChanged && state.gameState === 'mp-lobby') {
          updateLobbyUI(players);
        }

        // Update waiting status
        if (state.gameState === 'mp-waiting' && room.players) {
          const submitted = Object.values(room.players).filter(p => p.submitted).length;
          const total = players.length;
          updateWaitingStatus(submitted, total);
        }
      });
    }

    function stopRoomListener() {
      if (roomListener && state.roomId) {
        db.ref(`boggle/rooms/${state.roomId}`).off('value', roomListener);
        roomListener = null;
      }
    }

    function updateLobbyUI(players) {
      const playersList = document.getElementById('playersList');
      const playerCount = document.getElementById('playerCount');

      if (playersList && playerCount) {
        playerCount.textContent = players.length;
        playersList.innerHTML = players.map((p, i) =>
          `<div class="flex items-center justify-center gap-2 text-white">
            <span class="w-2 h-2 bg-green-400 rounded-full"></span>
            <span>${p}${i === 0 ? ' (host)' : ''}</span>
          </div>`
        ).join('');

        // Update Start button state for host
        if (state.isHost) {
          const startBtn = document.querySelector('button[onclick="mpHostStartGame()"]');
          if (startBtn) {
            startBtn.disabled = players.length < 2;
            startBtn.style.opacity = players.length < 2 ? '0.5' : '1';
          }
        }
      }
    }

    function updateWaitingStatus(submitted, total) {
      const waitingEl = document.getElementById('waitingStatus');
      if (waitingEl) {
        waitingEl.textContent = `${submitted}/${total} players finished`;
      }
    }

    // ============================================
    // RESULTS CALCULATION
    // ============================================

    async function calculateAndSetResults(roomId) {
      try {
        const roomSnapshot = await db.ref(`boggle/rooms/${roomId}`).once('value');
        const room = roomSnapshot.val();

        if (!room || !room.players) {
          console.error('Room or players not found');
          return;
        }

        // Collect all words by player
        const playerWords = {};
        const playerNames = Object.keys(room.players);
        playerNames.forEach(name => {
          const data = room.players[name];
          playerWords[name] = data.words ? data.words.split(',').map(w => w.trim().toLowerCase()).filter(w => w) : [];
        });

        // Find duplicates (words found by multiple players)
        const wordCounts = {};
        Object.values(playerWords).forEach(words => {
          words.forEach(word => {
            wordCounts[word] = (wordCounts[word] || 0) + 1;
          });
        });
        const duplicates = Object.keys(wordCounts).filter(w => wordCounts[w] > 1);

        // Calculate scores (excluding duplicates)
        const results = playerNames.map(name => {
          const words = playerWords[name];
          const uniqueWords = words.filter(w => !duplicates.includes(w));
          const score = uniqueWords.reduce((total, word) => total + getWordScore(word), 0);
          return { name, words, uniqueWords, score };
        });

        // Sort by score descending
        results.sort((a, b) => b.score - a.score);

        // Update room with results
        await db.ref(`boggle/rooms/${roomId}`).update({
          status: 'finished',
          results: {
            players: results,
            duplicates: duplicates,
            status: 'finished'
          }
        });

        console.log('Results calculated and saved');
      } catch (e) {
        console.error('Error calculating results:', e);
      }
    }

    // ============================================
    // ROOM CLEANUP
    // ============================================

    async function cleanupOldRooms() {
      try {
        const oneHourAgo = Date.now() - (60 * 60 * 1000);
        const roomsRef = db.ref('boggle/rooms');
        const snapshot = await roomsRef.orderByChild('createdAt').endAt(oneHourAgo).limitToFirst(10).once('value');

        const deletePromises = [];
        snapshot.forEach(child => {
          deletePromises.push(db.ref(`boggle/rooms/${child.key}`).remove());
        });

        await Promise.all(deletePromises);
      } catch (e) {
        console.error('Cleanup error:', e);
      }
    }

    // Get tile from point - improved for mobile with expanded hit detection
    function getTileFromPoint(x, y) {
      // First try exact hit
      const el = document.elementFromPoint(x, y);
      if (el && el.dataset && el.dataset.index !== undefined) {
        return parseInt(el.dataset.index);
      }

      // Fallback: find nearest tile within expanded touch radius
      let nearestIndex = -1;
      let nearestDist = Infinity;
      const touchRadius = 30; // pixels of tolerance around tile edges

      for (let i = 0; i < tileElements.length; i++) {
        const rect = tileElements[i].getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        // Check if within expanded bounds (tile + tolerance)
        const expandedLeft = rect.left - touchRadius;
        const expandedRight = rect.right + touchRadius;
        const expandedTop = rect.top - touchRadius;
        const expandedBottom = rect.bottom + touchRadius;

        if (x >= expandedLeft && x <= expandedRight && y >= expandedTop && y <= expandedBottom) {
          // Calculate distance to tile center
          const dist = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestIndex = i;
          }
        }
      }

      return nearestIndex;
    }

    // Update tile visuals without full re-render
    function updateTileVisuals() {
      tileElements.forEach((tile, index) => {
        const isSelected = state.selectedPath.includes(index);
        const isLast = state.selectedPath[state.selectedPath.length - 1] === index;

        tile.className = 'aspect-square rounded-xl text-2xl font-bold transition-all duration-100 select-none tile ';
        if (isSelected) {
          tile.className += isLast ? 'bg-yellow-400 text-green-900 scale-110 shadow-lg ring-4 ring-yellow-300' : 'bg-teal-400 text-white';
        } else {
          tile.className += 'bg-white text-green-800';
        }
        if (state.gameState !== 'playing') tile.className += ' opacity-75';
      });

      // Update current word display
      const wordDisplay = document.getElementById('currentWordDisplay');
      if (wordDisplay) {
        wordDisplay.textContent = state.currentWord || (state.inputMode === 'swipe' ? 'Swipe letters...' : 'Tap letters...');
      }

      // Update swipe lines
      updateSwipeLines();
    }

    // Update swipe lines SVG
    function updateSwipeLines() {
      const svg = document.getElementById('swipeSvg');
      if (!svg) return;

      if (state.selectedPath.length > 1) {
        let lines = '';
        for (let i = 0; i < state.selectedPath.length - 1; i++) {
          const from = tileElements[state.selectedPath[i]];
          const to = tileElements[state.selectedPath[i + 1]];
          if (from && to) {
            const svgRect = svg.getBoundingClientRect();
            const fromRect = from.getBoundingClientRect();
            const toRect = to.getBoundingClientRect();
            const x1 = fromRect.left + fromRect.width / 2 - svgRect.left;
            const y1 = fromRect.top + fromRect.height / 2 - svgRect.top;
            const x2 = toRect.left + toRect.width / 2 - svgRect.left;
            const y2 = toRect.top + toRect.height / 2 - svgRect.top;
            lines += '<line class="swipe-line" x1="' + x1 + '" y1="' + y1 + '" x2="' + x2 + '" y2="' + y2 + '"/>';
          }
        }
        svg.innerHTML = lines;
      } else {
        svg.innerHTML = '';
      }
    }

    // Handle drag start
    function handleDragStart(index, e) {
      if (state.gameState !== 'playing' || state.inputMode !== 'swipe') return;
      e.preventDefault();
      e.stopPropagation();
      state.isDragging = true;
      state.lastTouchTime = Date.now();
      state.selectedPath = [index];
      state.currentWord = state.board[index];
      state.pendingTile = null;
      clearTimeout(state.pendingTimeout);
      // Set initial touch position
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      state.lastTouchX = clientX;
      state.lastTouchY = clientY;
      updateTileVisuals();
    }

    // Check if tile is diagonal from another
    function isDiagonal(pos1, pos2) {
      const row1 = Math.floor(pos1 / 4), col1 = pos1 % 4;
      const row2 = Math.floor(pos2 / 4), col2 = pos2 % 4;
      return Math.abs(row1 - row2) === 1 && Math.abs(col1 - col2) === 1;
    }

    // Get tile center position
    function getTileCenterPos(index) {
      const tile = tileElements[index];
      if (!tile) return null;
      const rect = tile.getBoundingClientRect();
      return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
    }

    // Handle drag move - simplified and reliable
    function handleDragMove(e) {
      if (!state.isDragging || state.gameState !== 'playing' || state.inputMode !== 'swipe') return;
      e.preventDefault();

      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;

      const lastIndex = state.selectedPath[state.selectedPath.length - 1];

      // First, check what tile is directly under the touch
      const touchedIndex = getTileFromPoint(clientX, clientY);

      // Handle backtracking - if touching the previous tile
      if (state.selectedPath.length >= 2 && touchedIndex === state.selectedPath[state.selectedPath.length - 2]) {
        state.selectedPath = state.selectedPath.slice(0, -1);
        state.currentWord = state.selectedPath.map(i => state.board[i]).join('');
        updateTileVisuals();
        return;
      }

      // If touched tile is valid (adjacent and not selected), check if we should prefer a diagonal
      if (touchedIndex !== -1 && touchedIndex !== lastIndex &&
          !state.selectedPath.includes(touchedIndex) && areAdjacent(lastIndex, touchedIndex)) {

        const lastPos = getTileCenterPos(lastIndex);
        if (lastPos) {
          const dx = clientX - lastPos.x;
          const dy = clientY - lastPos.y;

          // Check if swiping diagonally
          const swipeAngle = Math.atan2(Math.abs(dy), Math.abs(dx));
          const isDiagonalSwipe = swipeAngle > 0.4 && swipeAngle < 1.17; // ~23Â° to ~67Â°

          // If swiping diagonally but touched an orthogonal tile, look for a diagonal
          if (isDiagonalSwipe && !isDiagonal(lastIndex, touchedIndex)) {
            // Find diagonal tile in swipe direction
            for (let i = 0; i < 16; i++) {
              if (state.selectedPath.includes(i) || !areAdjacent(lastIndex, i) || !isDiagonal(lastIndex, i)) continue;

              const diagPos = getTileCenterPos(i);
              if (!diagPos) continue;

              const toDiagX = diagPos.x - lastPos.x;
              const toDiagY = diagPos.y - lastPos.y;

              // Check if diagonal is in our swipe direction
              if ((dx > 0) === (toDiagX > 0) && (dy > 0) === (toDiagY > 0)) {
                addTileToPath(i);
                return;
              }
            }
          }
        }

        // Add the touched tile
        addTileToPath(touchedIndex);
      }
    }

    // Add tile to path helper
    function addTileToPath(index) {
      if (!state.selectedPath.includes(index) && areAdjacent(state.selectedPath[state.selectedPath.length - 1], index)) {
        state.selectedPath.push(index);
        state.currentWord = state.selectedPath.map(i => state.board[i]).join('');
        updateTileVisuals();
      }
    }

    // Handle drag end
    function handleDragEnd(e) {
      if (!state.isDragging) return;
      state.isDragging = false;
      state.lastTouchTime = Date.now();
      // Clear pending tile
      clearTimeout(state.pendingTimeout);
      state.pendingTile = null;
      if (state.selectedPath.length > 0 && state.currentWord.length >= 3) {
        submitWord();
      } else {
        clearSelection();
      }
    }

    // Handle tile tap (for tap mode)
    function handleTileTap(index, e) {
      // Prevent ghost clicks after touch
      if (e.type === 'click' && Date.now() - state.lastTouchTime < 500) {
        e.preventDefault();
        return;
      }

      if (state.gameState !== 'playing' || state.inputMode !== 'tap') return;

      if (e.type === 'touchstart') {
        e.preventDefault();
        state.lastTouchTime = Date.now();
      }

      if (state.selectedPath.length === 0) {
        state.selectedPath = [index];
        state.currentWord = state.board[index];
      } else if (state.selectedPath.includes(index)) {
        if (state.selectedPath[state.selectedPath.length - 1] === index && state.selectedPath.length > 1) {
          state.selectedPath = state.selectedPath.slice(0, -1);
          state.currentWord = state.selectedPath.map(i => state.board[i]).join('');
        } else if (state.selectedPath.length === 1) {
          state.selectedPath = [];
          state.currentWord = '';
        }
      } else if (areAdjacent(state.selectedPath[state.selectedPath.length - 1], index)) {
        state.selectedPath.push(index);
        state.currentWord += state.board[index];
      }
      updateTileVisuals();
    }

    // Clear selection
    function clearSelection() {
      state.selectedPath = [];
      state.currentWord = '';
      render();
    }

    // Submit word
    function submitWord() {
      const word = state.inputMode === 'type' ? state.typedWord.toLowerCase() : state.currentWord.toLowerCase();
      
      if (word.length < 3) {
        showMessage('Words must be at least 3 letters');
        clearSelection();
        state.typedWord = '';
        render();
        return;
      }
      
      if (state.foundWords.includes(word)) {
        animateTiles([...state.selectedPath], 'tile-shake'); showMessage('Already found!');
        clearSelection();
        state.typedWord = '';
        render();
        return;
      }
      
      if (!DICTIONARY.has(word)) {
        animateTiles([...state.selectedPath], 'tile-shake');
        clearSelection();
        state.typedWord = '';
        render();
        return;
      }
      
      if (state.inputMode === 'type' && !canFormWord(word, state.board)) {
        showMessage('Cannot form on board');
        state.typedWord = '';
        render();
        return;
      }
      
      const wordScore = getWordScore(word);
      const pathCopy = [...state.selectedPath];
      const lastTile = getTileCenter(pathCopy[pathCopy.length - 1] || 0);

      state.foundWords.push(word);
      state.score += wordScore;

      // Quick visual updates
      showFloatingPoints(wordScore, lastTile.x - 20, lastTile.y - 20);
      animateTiles(pathCopy, 'tile-bounce');
      updateScoreDisplay();

      // Clear and update
      state.selectedPath = [];
      state.currentWord = '';
      state.typedWord = '';
      updateTileVisuals();

      // Full render to update found words list
      render();
    }

    // Quick score update without full render
    function updateScoreDisplay() {
      const scoreEl = document.getElementById('scoreDisplay');
      if (scoreEl) scoreEl.textContent = state.score + ' pts';
    }

    // Show message
    function showMessage(msg) {
      state.message = msg;
      // Update message element directly if it exists
      const msgEl = document.getElementById('messageDisplay');
      if (msgEl) {
        msgEl.innerHTML = msg ? `<span class="bg-white/20 text-white px-4 py-2 rounded-full font-medium">${msg}</span>` : '';
      } else {
        render();
      }
      // Always clear message after 1.5 seconds
      if (msg) {
        setTimeout(() => {
          state.message = '';
          const el = document.getElementById('messageDisplay');
          if (el) {
            el.innerHTML = '';
          }
        }, 1500);
      }
    }

    // Format time
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Share results
    function shareResults() {
      // Find longest word (count Qu as 1 letter)
      let longestWord = '';
      state.foundWords.forEach(word => {
        const len = word.replace(/qu/gi, 'Q').length;
        const longestLen = longestWord.replace(/qu/gi, 'Q').length;
        if (len > longestLen) longestWord = word;
      });
      const longestLen = longestWord ? longestWord.replace(/qu/gi, 'Q').length : 0;

      // Score emoji based on performance
      let scoreEmoji = 'ðŸŽ¯';
      if (state.score >= 100) scoreEmoji = 'ðŸ†';
      else if (state.score >= 50) scoreEmoji = 'ðŸ”¥';
      else if (state.score >= 25) scoreEmoji = 'â­';

      // Word length stars
      const stars = 'â¬›'.repeat(Math.min(longestLen, 8));

      const shareText = `ðŸŽ² Daily Boggle ðŸŽ²\nðŸ“… ${state.todayDate}\n${scoreEmoji} ${state.score} points\nðŸ“ Longest: ${longestLen} letters\n${stars}`;

      if (navigator.share) {
        navigator.share({ text: shareText }).catch(() => copyToClipboard(shareText));
      } else {
        copyToClipboard(shareText);
      }
    }

    // Copy to clipboard
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text);
      showMessage('Copied to clipboard!');
    }

    // Calculate all possible words on the board
    function getAllPossibleWords() {
      const possibleWords = [];
      DICTIONARY.forEach(word => {
        if (word.length >= 3 && canFormWord(word, state.board)) {
          possibleWords.push(word);
        }
      });
      return possibleWords;
    }

    // Login
    async function handleLogin() {
      const nameInput = document.getElementById('playerName');
      const name = nameInput.value.trim();
      if (!name) return;

      // Refresh date in case page was left open overnight
      const currentDate = getTodayString();
      if (state.todayDate !== currentDate) {
        state.todayDate = currentDate;
        state.board = generateDailyBoard(currentDate);
      }

      state.playerName = name;
      localStorage.setItem('boggle_player', name);

      // Show loading state immediately
      const btn = document.querySelector('button[onclick="handleLogin()"]');
      if (btn) btn.textContent = 'Loading...';

      // Run API calls in parallel with timeout
      const timeout = (ms) => new Promise((_, reject) => setTimeout(() => reject('timeout'), ms));

      try {
        const [check, leaderboard] = await Promise.all([
          Promise.race([checkPlayer(name), timeout(3000)]).catch(() => ({ played: false })),
          Promise.race([getLeaderboard(), timeout(3000)]).catch(() => [])
        ]);

        state.leaderboard = leaderboard;

        if (check.played) {
          state.score = check.score;
          state.foundWords = [];
          state.gameState = 'finished';
          showMessage("You've already played today!");
        } else {
          state.gameState = 'ready';
        }
      } catch (e) {
        // If API fails, just let them play
        state.gameState = 'ready';
      }

      render();
    }

    // Start game
    function startGame() {
      // In practice mode, check if a code was entered and load that board
      if (state.practiceMode) {
        const codeInput = document.getElementById('practiceCodeInput');
        if (codeInput && codeInput.value.trim()) {
          const code = parseInt(codeInput.value.trim());
          if (code >= 10000 && code <= 99999) {
            state.practiceCode = code;
            state.board = generateSeededBoard(code);
          }
        }
      }

      state.gameState = 'playing';
      state.foundWords = [];
      state.score = 0;
      state.timeLeft = 180;
      state.message = '';
      state.possibleWords = null;

      // Track actual end time so timer works even when tab is backgrounded
      const endTime = Date.now() + 180 * 1000;

      state.timerInterval = setInterval(() => {
        const remaining = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
        state.timeLeft = remaining;

        if (remaining <= 0) {
          endGame();
        } else {
          // Quick timer update without full render
          const timerEl = document.getElementById('timerDisplay');
          if (timerEl) {
            timerEl.textContent = 'â± ' + formatTime(remaining);
            timerEl.className = 'text-2xl font-mono font-bold ' + (remaining <= 30 ? 'text-red-300 timer-urgent' : 'text-white');
          }
        }
      }, 1000);

      render();
    }

    // Start practice mode
    function startPracticeMode() {
      const nameInput = document.getElementById('playerName');
      const name = nameInput ? nameInput.value.trim() : 'player';
      state.playerName = name || 'player';
      state.practiceMode = true;
      state.board = generateRandomBoard();
      state.gameState = 'ready';
      state.leaderboard = [];
      render();
    }

    // ============================================
    // MULTIPLAYER FUNCTIONS
    // ============================================

    function showMultiplayerMenu() {
      const nameInput = document.getElementById('playerName');
      const name = nameInput ? nameInput.value.trim() : '';
      if (!name) {
        showMessage('Enter your name first');
        return;
      }
      state.playerName = name;
      localStorage.setItem('boggle_player', name);
      state.gameState = 'mp-menu';
      render();
    }

    async function hostGame() {
      // Update button to show loading state
      const btn = document.querySelector('button[onclick="hostGame()"]');
      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Creating...';
        btn.style.opacity = '0.7';
      }

      const boardCode = generatePracticeCode();
      state.practiceCode = boardCode;
      state.board = generateSeededBoard(boardCode);

      const result = await mpCreateRoom(state.playerName, boardCode);

      if (result.error) {
        showMessage(result.error);
        // Reset button
        if (btn) {
          btn.disabled = false;
          btn.textContent = 'Host Game';
          btn.style.opacity = '1';
        }
        return;
      }

      state.multiplayerMode = true;
      state.roomId = result.roomId;
      state.isHost = true;
      state.roomPlayers = [state.playerName];
      state.roomStatus = 'waiting';
      state.gameState = 'mp-lobby';

      // Start real-time listener for room updates
      startRoomListener();
      render();
    }

    async function joinGame() {
      const codeInput = document.getElementById('roomCodeInput');
      const roomId = codeInput ? codeInput.value.trim() : '';

      if (!roomId || roomId.length !== 5 || !/^\d{5}$/.test(roomId)) {
        showMessage('Enter a 5-digit room code');
        return;
      }

      // Update button to show loading state
      const btn = document.querySelector('button[onclick="joinGame()"]');
      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Joining...';
        btn.style.opacity = '0.7';
      }

      const result = await mpJoinRoom(roomId, state.playerName);

      if (result.error) {
        showMessage(result.error);
        // Reset button
        if (btn) {
          btn.disabled = false;
          btn.textContent = 'Join Game';
          btn.style.opacity = '1';
        }
        return;
      }

      state.multiplayerMode = true;
      state.roomId = roomId;
      state.isHost = false;
      state.roomPlayers = result.players;
      state.practiceCode = result.boardCode;
      state.board = generateSeededBoard(result.boardCode);
      state.roomStatus = 'waiting';
      state.gameState = 'mp-lobby';

      // Start real-time listener for room updates
      startRoomListener();
      render();
    }

    async function mpHostStartGame() {
      // Stop listener immediately to prevent re-renders
      stopRoomListener();
      state.roomStatus = 'starting';
      render();

      const result = await mpStartRoom(state.roomId);

      if (result.error) {
        showMessage(result.error);
        state.roomStatus = 'waiting';
        startRoomListener();
        return;
      }

      state.mpStartTime = result.startTime;
      startMultiplayerGame(result.startTime);
    }

    function startMultiplayerGame(startTime) {
      // Prevent multiple countdowns
      if (state.gameState === 'mp-countdown' || state.gameState === 'playing') return;

      // Clear any existing countdown
      if (state.countdownInterval) {
        clearInterval(state.countdownInterval);
        state.countdownInterval = null;
      }

      // Validate startTime
      if (!startTime || typeof startTime !== 'number') {
        console.error('Invalid startTime:', startTime);
        beginMultiplayerPlay();
        return;
      }

      // If startTime already passed, start immediately
      const initialRemaining = Math.ceil((startTime - Date.now()) / 1000);
      if (initialRemaining <= 0) {
        beginMultiplayerPlay();
        return;
      }

      state.gameState = 'mp-countdown';
      render();

      // Update initial display
      const countdownEl = document.getElementById('countdownDisplay');
      if (countdownEl) countdownEl.textContent = initialRemaining;

      state.countdownInterval = setInterval(() => {
        const remaining = Math.ceil((startTime - Date.now()) / 1000);

        if (remaining <= 0) {
          clearInterval(state.countdownInterval);
          state.countdownInterval = null;
          beginMultiplayerPlay();
        } else {
          // Update countdown display
          const el = document.getElementById('countdownDisplay');
          if (el) el.textContent = remaining;
        }
      }, 250);
    }

    function beginMultiplayerPlay() {
      state.gameState = 'playing';
      state.foundWords = [];
      state.score = 0;
      state.timeLeft = 180;
      state.message = '';
      state.possibleWords = null;

      const endTime = Date.now() + 180 * 1000;

      state.timerInterval = setInterval(() => {
        const remaining = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
        state.timeLeft = remaining;

        if (remaining <= 0) {
          endMultiplayerGame();
        } else {
          const timerEl = document.getElementById('timerDisplay');
          if (timerEl) {
            timerEl.textContent = 'â± ' + formatTime(remaining);
            timerEl.className = 'text-2xl font-mono font-bold ' + (remaining <= 30 ? 'text-red-300 timer-urgent' : 'text-white');
          }
        }
      }, 1000);

      render();
    }

    async function endMultiplayerGame() {
      clearInterval(state.timerInterval);
      state.gameState = 'mp-waiting';
      state.mpSubmitted = false;
      clearSelection();

      if (navigator.vibrate) navigator.vibrate([100, 50, 100]);

      render();

      // Submit words to server
      showMessage('Submitting words...');
      const submitResult = await mpSubmitWords(state.roomId, state.playerName, state.foundWords);

      // Mark as submitted and re-render to show button
      state.mpSubmitted = true;

      if (submitResult.error) {
        showMessage('Error submitting words. Retrying...');
        // Retry once
        await mpSubmitWords(state.roomId, state.playerName, state.foundWords);
      }

      render();

      // Real-time listener handles results - restart it
      startRoomListener();

      // Fallback: check for results after 3 seconds if listener doesn't trigger
      setTimeout(async () => {
        if (state.gameState === 'mp-waiting') {
          console.log('Fallback: checking for results...');
          const room = await db.ref(`boggle/rooms/${state.roomId}`).once('value');
          if (room.exists() && room.val().status === 'finished') {
            fetchResults();
          }
        }
      }, 3000);
    }

    function forceResults() {
      stopRoomListener();
      fetchResults();
    }

    async function fetchResults() {
      const result = await mpGetResults(state.roomId);

      if (result.error) {
        showMessage(result.error);
        return;
      }

      // Ensure results have expected structure
      if (!result.duplicates) result.duplicates = [];
      if (!result.players) result.players = [];

      state.mpResults = result;
      state.gameState = 'mp-results';
      render();

      // Restart listener so non-host players can detect when host starts new game
      startRoomListener();
    }

    function leaveRoom() {
      stopRoomListener();
      mpLeaveRoom(state.roomId, state.playerName);
      resetMultiplayerState();
      state.gameState = 'login';
      render();
    }

    function resetMultiplayerState() {
      state.multiplayerMode = false;
      state.roomId = null;
      state.isHost = false;
      state.roomPlayers = [];
      state.roomStatus = null;
      state.mpResults = null;
      state.mpStartTime = null;
      state.mpSubmitted = false;
      if (state.countdownInterval) {
        clearInterval(state.countdownInterval);
        state.countdownInterval = null;
      }
      stopRoomListener();
    }

    function copyRoomCode() {
      if (state.roomId) {
        navigator.clipboard.writeText(state.roomId);
        showMessage('Room code copied!');
      }
    }

    async function mpPlayAgain() {
      // Reset room with new board, keep same players
      const newBoardCode = Math.floor(Math.random() * 100000);

      // Get current players and reset their state
      const roomRef = db.ref(`boggle/rooms/${state.roomId}`);
      const snapshot = await roomRef.once('value');
      const room = snapshot.val();

      if (!room) {
        showMessage('Room not found');
        return;
      }

      // Reset each player's submitted/words state
      const resetPlayers = {};
      Object.keys(room.players).forEach(name => {
        resetPlayers[name] = {
          joinedAt: room.players[name].joinedAt,
          submitted: false
        };
      });

      // Update room with new board and reset state
      await roomRef.update({
        boardCode: newBoardCode,
        status: 'waiting',
        startTime: null,
        results: null,
        players: resetPlayers
      });

      // Update local state
      state.board = generateSeededBoard(newBoardCode);
      state.practiceCode = newBoardCode;
      state.foundWords = [];
      state.score = 0;
      state.mpSubmitted = false;
      state.mpResults = null;
      state.gameState = 'mp-lobby';

      startRoomListener();
      render();
    }

    function mpExit() {
      leaveRoom();
    }

    // Load board from code
    function loadBoardFromCode() {
      const codeInput = document.getElementById('practiceCodeInput');
      const code = parseInt(codeInput.value.trim());
      if (code >= 10000 && code <= 99999) {
        state.practiceCode = code;
        state.board = generateSeededBoard(code);
        state.possibleWords = null;
        render();
      } else {
        showMessage('Enter a 5-digit code');
      }
    }

    // Copy practice code
    function copyPracticeCode() {
      if (state.practiceCode) {
        navigator.clipboard.writeText(state.practiceCode.toString());
        showMessage('Code copied!');
      }
    }

    // New game - go back to ready screen to enter codes (practice mode)
    function newGame() {
      state.board = generateRandomBoard();
      state.possibleWords = null;
      state.foundWords = [];
      state.score = 0;
      state.gameState = 'ready';
      render();
    }

    // Replay same board (practice mode)
    function replayBoard() {
      state.possibleWords = null;
      startGame();
    }

    // Back to main menu
    function backToMenu() {
      state.gameState = 'login';
      state.practiceMode = false;
      state.foundWords = [];
      state.score = 0;
      state.possibleWords = null;
      state.board = generateDailyBoard(state.todayDate);
      render();
    }

    // Remove word and recalculate score (practice mode)
    function removeWord(word) {
      const index = state.foundWords.indexOf(word);
      if (index > -1) {
        state.foundWords.splice(index, 1);
        state.score = state.foundWords.reduce((total, w) => total + getWordScore(w), 0);
        render();
      }
    }

    // End game
    async function endGame() {
      clearInterval(state.timerInterval);
      state.gameState = 'finished';
      clearSelection();

      // Haptic vibration on game end (Android only - iOS doesn't support Vibration API)
      if (navigator.vibrate) navigator.vibrate([100, 50, 100]);

      // Render finished state immediately, don't wait for API
      render();

      // Calculate possible words in background
      setTimeout(() => {
        state.possibleWords = getAllPossibleWords();
        render();
      }, 100);

      // Skip saving score in practice mode
      if (state.practiceMode) return;

      // Save score and get leaderboard in background
      try {
        await saveScore(state.playerName, state.score, state.foundWords.length);
        state.leaderboard = await getLeaderboard();
        render(); // Re-render with leaderboard
      } catch (e) {
        console.error('Error saving score:', e);
      }
    }

    // Set input mode
    function setInputMode(mode) {
      state.inputMode = mode;
      state.typedWord = '';
      clearSelection();
    }

    // Render
    function render() {
      const app = document.getElementById('app');
      
      // Login screen
      if (state.gameState === 'login') {
        app.innerHTML = `
          <div class="min-h-screen flex items-center justify-center p-4">
            <div class="bg-white/10 backdrop-blur rounded-2xl p-8 max-w-sm w-full text-center">
              <h1 class="text-3xl font-bold text-white mb-2">Daily Boggle</h1>
              <p class="text-blue-100 mb-6">${state.todayDate}</p>
              <input 
                type="text" 
                id="playerName" 
                placeholder="Enter your name"
                value="${state.playerName}"
                class="w-full px-4 py-3 rounded-xl text-lg text-center outline-none mb-4"
                onkeypress="if(event.key==='Enter')handleLogin()"
              />
              <button
                onclick="handleLogin()"
                class="w-full px-6 py-3 bg-green-500 hover:bg-green-400 rounded-xl text-white text-lg font-bold transition-colors"
              >
                Play Daily Game
              </button>
              <button
                onclick="startPracticeMode()"
                class="w-full px-6 py-3 mt-3 bg-white/20 hover:bg-white/30 rounded-xl text-white text-lg font-bold transition-colors"
              >
                Practice Mode
              </button>
              <button
                onclick="showMultiplayerMenu()"
                class="w-full px-6 py-3 mt-3 bg-purple-500 hover:bg-purple-400 rounded-xl text-white text-lg font-bold transition-colors"
              >
                Multiplayer
              </button>
            </div>
          </div>
        `;
        return;
      }

      // Multiplayer Menu
      if (state.gameState === 'mp-menu') {
        app.innerHTML = `
          <div class="min-h-screen flex items-center justify-center p-4">
            <div class="bg-white/10 backdrop-blur rounded-2xl p-8 max-w-sm w-full text-center">
              <h1 class="text-3xl font-bold text-white mb-2">Multiplayer</h1>
              <p class="text-blue-100 mb-6">Playing as ${state.playerName}</p>
              <button
                onclick="hostGame()"
                class="w-full px-6 py-3 bg-green-500 hover:bg-green-400 rounded-xl text-white text-lg font-bold transition-colors"
              >
                Host Game
              </button>
              <div class="my-4 text-white/50">â€” or â€”</div>
              <input
                type="text"
                id="roomCodeInput"
                placeholder="Enter room code"
                maxlength="5"
                inputmode="numeric"
                pattern="[0-9]*"
                class="w-full px-4 py-3 rounded-xl text-lg text-center outline-none mb-3 font-mono"
                onkeypress="if(event.key==='Enter')joinGame()"
              />
              <button
                onclick="joinGame()"
                class="w-full px-6 py-3 bg-blue-500 hover:bg-blue-400 rounded-xl text-white text-lg font-bold transition-colors"
              >
                Join Game
              </button>
              <button
                onclick="state.gameState='login'; render();"
                class="w-full px-6 py-3 mt-4 bg-white/20 hover:bg-white/30 rounded-xl text-white text-lg font-bold transition-colors"
              >
                â† Back
              </button>
            </div>
          </div>
        `;
        return;
      }

      // Multiplayer Lobby
      if (state.gameState === 'mp-lobby') {
        app.innerHTML = `
          <div class="min-h-screen flex items-center justify-center p-4">
            <div class="bg-white/10 backdrop-blur rounded-2xl p-8 max-w-sm w-full text-center">
              <h1 class="text-3xl font-bold text-white mb-2">Game Lobby</h1>
              <div class="mb-4">
                <p class="text-white/70 text-sm mb-1">Room Code</p>
                <div class="flex justify-center items-center gap-2">
                  <span class="text-4xl font-mono font-bold text-yellow-300 tracking-wider">${state.roomId}</span>
                  <button onclick="copyRoomCode()" class="px-3 py-1 bg-white/20 hover:bg-white/30 rounded-lg text-white text-sm transition-colors">Copy</button>
                </div>
              </div>
              <div class="bg-white/10 rounded-xl p-4 mb-4">
                <p class="text-white/70 text-sm mb-2">Players (<span id="playerCount">${state.roomPlayers.length}</span>)</p>
                <div id="playersList" class="space-y-2">
                  ${state.roomPlayers.map((p, i) => `
                    <div class="flex items-center justify-center gap-2 text-white">
                      <span class="w-2 h-2 bg-green-400 rounded-full"></span>
                      <span>${p}${i === 0 ? ' (host)' : ''}</span>
                    </div>
                  `).join('')}
                </div>
              </div>
              ${state.roomStatus === 'starting' ? `
                <div class="w-full px-6 py-3 bg-yellow-500 rounded-xl text-white text-lg font-bold mb-3 animate-pulse">
                  Starting...
                </div>
              ` : state.isHost ? `
                <button
                  onclick="mpHostStartGame()"
                  class="w-full px-6 py-3 bg-green-500 hover:bg-green-400 rounded-xl text-white text-lg font-bold transition-colors mb-3"
                  ${state.roomPlayers.length < 2 ? 'disabled style="opacity:0.5;cursor:not-allowed"' : ''}
                >
                  Start Game
                </button>
                ${state.roomPlayers.length < 2 ? '<p class="text-white/50 text-sm mb-3">Waiting for players to join...</p>' : ''}
              ` : `
                <p class="text-white/70 mb-4">Waiting for host to start...</p>
              `}
              <button
                onclick="leaveRoom()"
                class="w-full px-6 py-3 bg-white/20 hover:bg-white/30 rounded-xl text-white text-lg font-bold transition-colors"
              >
                Leave
              </button>
            </div>
          </div>
        `;
        return;
      }

      // Multiplayer Countdown
      if (state.gameState === 'mp-countdown') {
        app.innerHTML = `
          <div class="min-h-screen flex items-center justify-center p-4">
            <div class="text-center">
              <p class="text-white text-2xl mb-4">Game starting in...</p>
              <div id="countdownDisplay" class="text-8xl font-bold text-yellow-300">5</div>
            </div>
          </div>
        `;
        return;
      }

      // Multiplayer Waiting for Results
      if (state.gameState === 'mp-waiting') {
        app.innerHTML = `
          <div class="min-h-screen flex items-center justify-center p-4">
            <div class="bg-white/10 backdrop-blur rounded-2xl p-8 max-w-sm w-full text-center">
              <h1 class="text-2xl font-bold text-white mb-4">Time's Up!</h1>
              <p class="text-white mb-2">Your score: <span class="text-yellow-300 font-bold">${state.score} pts</span></p>
              <p class="text-white mb-4">${state.foundWords.length} words found</p>
              <div class="animate-pulse mb-4">
                <p id="waitingStatus" class="text-white/70">${state.mpSubmitted ? 'Waiting for other players...' : 'Submitting your words...'}</p>
              </div>
              ${state.mpSubmitted ? `
                <button onclick="forceResults()" class="px-6 py-2 bg-white/20 hover:bg-white/30 rounded-xl text-white font-bold transition-colors text-sm">
                  View Results Anyway
                </button>
              ` : ''}
            </div>
          </div>
        `;
        return;
      }

      // Multiplayer Results
      if (state.gameState === 'mp-results') {
        const results = state.mpResults;
        const myResult = results.players.find(p => p.name.toLowerCase() === state.playerName.toLowerCase());

        // Calculate group stats
        const allFoundWords = new Set();
        results.players.forEach(p => {
          (p.words || []).forEach(w => allFoundWords.add(w.toLowerCase()));
        });
        const totalFound = allFoundWords.size;
        const totalPossible = getAllPossibleWords().length;
        const percentFound = totalPossible > 0 ? Math.round((totalFound / totalPossible) * 100) : 0;
        const myWordCount = myResult ? myResult.words.length : 0;
        const myPercent = totalPossible > 0 ? Math.round((myWordCount / totalPossible) * 100) : 0;

        app.innerHTML = `
          <div class="max-w-md mx-auto p-4">
            <div class="text-center mb-4">
              <h1 class="text-3xl font-bold text-white mb-1">Results</h1>
              <p class="text-blue-100 text-sm">Room ${state.roomId}</p>
            </div>

            <div class="bg-white/10 backdrop-blur rounded-2xl p-4 mb-4">
              <h2 class="text-white font-bold mb-3 text-center">Final Scores</h2>
              <div class="space-y-2">
                ${results.players.map((p, i) => {
                  const medal = i === 0 ? 'ðŸ¥‡' : i === 1 ? 'ðŸ¥ˆ' : i === 2 ? 'ðŸ¥‰' : '';
                  const isMe = p.name === state.playerName;
                  return `
                    <div class="flex justify-between items-center ${isMe ? 'bg-white/20 rounded-lg px-3 py-2' : 'px-3 py-1'}">
                      <span class="text-white">${medal} ${p.name}${isMe ? ' (you)' : ''}</span>
                      <span class="text-yellow-300 font-bold">${p.score} pts</span>
                    </div>
                  `;
                }).join('')}
              </div>
            </div>

            ${myResult ? `
              <div class="bg-white/10 backdrop-blur rounded-2xl p-4 mb-4">
                <h3 class="text-white font-bold mb-2">Your Words (${myResult.words.length})</h3>
                <div class="flex flex-wrap gap-2">
                  ${myResult.words.sort().map(word => {
                    const isDuplicate = results.duplicates.includes(word);
                    return isDuplicate
                      ? `<span class="bg-red-500/30 text-red-200 px-2 py-1 rounded text-sm line-through">${word.toUpperCase()}</span>`
                      : `<span class="bg-green-500/30 text-green-200 px-2 py-1 rounded text-sm">${word.toUpperCase()} +${getWordScore(word)}</span>`;
                  }).join('')}
                </div>
                ${results.duplicates.length > 0 ? `
                  <p class="text-white/50 text-xs mt-2">Crossed out words were found by multiple players</p>
                ` : ''}
              </div>
            ` : ''}

            <div class="bg-white/10 backdrop-blur rounded-2xl p-4 mb-4">
              <h3 class="text-white font-bold mb-2 text-center">Stats</h3>
              <div class="flex justify-around text-center mb-3">
                <div>
                  <p class="text-2xl font-bold text-yellow-300">${totalFound}</p>
                  <p class="text-white/70 text-xs">Group Found</p>
                </div>
                <div>
                  <p class="text-2xl font-bold text-blue-300">${totalPossible}</p>
                  <p class="text-white/70 text-xs">Possible</p>
                </div>
                <div>
                  <p class="text-2xl font-bold text-green-300">${percentFound}%</p>
                  <p class="text-white/70 text-xs">Group Coverage</p>
                </div>
              </div>
              <div class="border-t border-white/20 pt-3 text-center">
                <p class="text-white/70 text-sm">You found <span class="text-purple-300 font-bold">${myWordCount}</span> words (<span class="text-purple-300 font-bold">${myPercent}%</span> of possible)</p>
              </div>
            </div>

            <div class="flex gap-2">
              ${state.isHost ? `
                <button onclick="mpPlayAgain()" class="flex-1 px-6 py-3 bg-green-500 hover:bg-green-400 rounded-xl text-white font-bold transition-colors">
                  Play Again
                </button>
              ` : `
                <div class="flex-1 px-6 py-3 bg-white/10 rounded-xl text-white/70 text-center text-sm">
                  Waiting for host...
                </div>
              `}
              <button onclick="mpExit()" class="flex-1 px-6 py-3 bg-white/20 hover:bg-white/30 rounded-xl text-white font-bold transition-colors">
                Exit
              </button>
            </div>
          </div>
        `;
        return;
      }

      let html = `<div class="max-w-md mx-auto p-4">`;
      
      // Header
      const title = state.multiplayerMode ? 'Multiplayer' : (state.practiceMode ? 'Practice Mode' : 'Daily Boggle');
      const subtitle = state.multiplayerMode ? `Room ${state.roomId} â€¢ ${state.playerName}` : (state.practiceMode ? state.playerName : `${state.todayDate} â€¢ ${state.playerName}`);
      html += `
        <div class="text-center mb-4">
          <h1 class="text-3xl font-bold text-white mb-1">${title}</h1>
          <p class="text-blue-100 text-sm">${subtitle}</p>
        </div>
      `;
      
      // Timer and Score (playing)
      if (state.gameState === 'playing') {
        html += `
          <div class="flex justify-between items-center mb-4 px-2">
            <div id="timerDisplay" class="text-2xl font-mono font-bold ${state.timeLeft <= 30 ? 'text-red-300 timer-urgent' : 'text-white'}">
              â± ${formatTime(state.timeLeft)}
            </div>
            <div id="scoreDisplay" class="text-2xl font-bold text-yellow-300">${state.score} pts</div>
          </div>
        `;
      }

      // Game Board (only show during playing and finished)
      if (state.gameState === 'playing' || state.gameState === 'finished') {
        html += `<div class="bg-white/10 backdrop-blur rounded-2xl p-4 mb-4 select-none board-container"><svg class="swipe-svg" id="swipeSvg"></svg><div class="grid grid-cols-4 gap-2">`;

        state.board.forEach((letter, index) => {
          const isSelected = state.selectedPath.includes(index);
          const isLast = state.selectedPath[state.selectedPath.length - 1] === index;

          let tileClass = 'aspect-square rounded-xl text-2xl font-bold transition-all duration-100 select-none tile ';
          if (isSelected) {
            tileClass += isLast ? 'bg-yellow-400 text-green-900 scale-110 shadow-lg ring-4 ring-yellow-300' : 'bg-teal-400 text-white';
          } else {
            tileClass += 'bg-white text-green-800';
          }
          if (state.gameState !== 'playing') tileClass += ' opacity-75';

          html += `<button class="${tileClass}" data-index="${index}">${letter}</button>`;
        });

        html += `</div></div>`;
      }
      
      // Input area (playing)
      if (state.gameState === 'playing') {
        html += `
          <div class="mb-4">
            <div class="flex justify-center gap-2 mb-3">
              <button onclick="setInputMode('swipe')" class="px-4 py-1 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'swipe' ? 'bg-white text-green-800' : 'bg-white/20 text-white'}">Swipe</button>
              <button onclick="setInputMode('tap')" class="px-4 py-1 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'tap' ? 'bg-white text-green-800' : 'bg-white/20 text-white'}">Tap</button>
              <button onclick="setInputMode('type')" class="px-4 py-1 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'type' ? 'bg-white text-green-800' : 'bg-white/20 text-white'}">Type</button>
            </div>
        `;
        
        if (state.inputMode === 'type') {
          html += `
            <div class="flex gap-2">
              <input type="text" id="typeInput" value="${state.typedWord}" placeholder="Type a word..." 
                class="flex-1 bg-white/20 rounded-xl px-4 py-3 text-white text-xl font-bold placeholder-white/50 outline-none focus:bg-white/30"
                autocomplete="off" autocapitalize="off" />
              <button onclick="submitWord()" class="px-6 bg-green-500 hover:bg-green-400 disabled:bg-gray-500 disabled:opacity-50 rounded-xl text-white font-bold transition-colors">âœ“</button>
            </div>
          `;
        } else {
          html += `
            <div class="flex gap-2">
              <div class="flex-1 bg-white/20 rounded-xl px-4 py-3 text-center min-h-[52px] flex items-center justify-center">
                <span id="currentWordDisplay" class="text-2xl font-bold text-white tracking-wider">${state.currentWord || (state.inputMode === 'swipe' ? 'Swipe letters...' : 'Tap letters...')}</span>
              </div>
              ${state.inputMode === 'tap' ? `
                <button onclick="submitWord()" class="px-6 bg-green-500 hover:bg-green-400 rounded-xl text-white font-bold transition-colors">âœ“</button>
                <button onclick="clearSelection()" class="px-4 bg-red-500 hover:bg-red-400 rounded-xl text-white font-bold transition-colors">âœ•</button>
              ` : ''}
            </div>
          `;
        }
        html += `</div>`;
      }
      
      // Message (always render container for quick updates)
      html += `<div id="messageDisplay" class="text-center mb-4">${state.message ? `<span class="bg-white/20 text-white px-4 py-2 rounded-full font-medium">${state.message}</span>` : ''}</div>`;
      
      // Ready state
      if (state.gameState === 'ready') {
        html += `
          <div class="bg-white/10 backdrop-blur rounded-2xl p-6 mb-4">
            <p class="text-green-100 text-center mb-6">Find as many words as you can in 3 minutes!<br/>Select adjacent letters to form words.</p>

            ${state.practiceMode ? `
            <div class="mb-6 text-center">
              <p class="text-white/70 text-sm mb-2">Board Code</p>
              <div class="flex justify-center items-center gap-2 mb-3">
                <span class="text-3xl font-mono font-bold text-yellow-300 tracking-wider">${state.practiceCode}</span>
                <button onclick="copyPracticeCode()" class="px-3 py-1 bg-white/20 hover:bg-white/30 rounded-lg text-white text-sm transition-colors">Copy</button>
              </div>
              <p class="text-white/50 text-xs mb-3">Share this code so others get the same board</p>
              <div class="flex justify-center items-center gap-2">
                <input type="text" id="practiceCodeInput" placeholder="Enter code" maxlength="5"
                  class="w-28 px-3 py-2 rounded-lg text-center font-mono text-lg outline-none" />
                <button onclick="state.board = generateRandomBoard(); render();" class="px-3 py-2 bg-white/20 hover:bg-white/30 rounded-lg text-white text-sm transition-colors">New</button>
              </div>
            </div>
            ` : ''}

            <div class="mb-6">
              <p class="text-white/70 text-sm text-center mb-3">Input Method</p>
              <div class="flex justify-center gap-2">
                <button onclick="setInputMode('swipe')" class="px-5 py-2 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'swipe' ? 'bg-white text-green-800' : 'bg-white/20 text-white hover:bg-white/30'}">Swipe</button>
                <button onclick="setInputMode('tap')" class="px-5 py-2 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'tap' ? 'bg-white text-green-800' : 'bg-white/20 text-white hover:bg-white/30'}">Tap</button>
                <button onclick="setInputMode('type')" class="px-5 py-2 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'type' ? 'bg-white text-green-800' : 'bg-white/20 text-white hover:bg-white/30'}">Type</button>
              </div>
            </div>

            <div class="text-center">
              <button onclick="startGame()" class="px-8 py-4 bg-green-500 hover:bg-green-400 rounded-2xl text-white text-xl font-bold transition-colors shadow-lg">Start Game</button>
            </div>
          </div>
        `;
      }
      
      // Finished state
      if (state.gameState === 'finished') {
        const possibleCount = state.possibleWords ? state.possibleWords.length : null;
        const percentFound = possibleCount ? Math.round((state.foundWords.length / possibleCount) * 100) : null;

        // Score message
        let scoreMessage = '';
        if (state.score <= 10) scoreMessage = 'Words may not be your thing!';
        else if (state.score <= 15) scoreMessage = 'Not bad!';
        else if (state.score <= 20) scoreMessage = 'Good job!';
        else scoreMessage = 'You did really good!';

        html += `
          <div class="text-center">
            <div class="bg-white/10 backdrop-blur rounded-2xl p-6 mb-4">
              <h2 class="text-xl font-bold text-white mb-2">${state.foundWords.length > 0 ? "Time's Up!" : "Today's Results"}</h2>
              <div class="text-4xl font-bold text-yellow-300 mb-2">${state.score} pts</div>
              <p class="text-white text-lg mb-1">${scoreMessage}</p>
              <p class="text-green-100">${state.foundWords.length} words found</p>
              <p class="text-green-200 text-sm mt-2">
                ${possibleCount !== null
                  ? `ðŸ“Š ${possibleCount} possible words (you found ${percentFound}%)`
                  : 'ðŸ“Š Calculating possible words...'}
              </p>
            </div>
            <div class="flex flex-wrap justify-center gap-2 mb-4">
              <button onclick="shareResults()" class="px-6 py-3 bg-blue-500 hover:bg-blue-400 rounded-xl text-white font-bold transition-colors">Share</button>
              ${state.practiceMode ? `
                <button onclick="newGame()" class="px-6 py-3 bg-green-500 hover:bg-green-400 rounded-xl text-white font-bold transition-colors">New Game</button>
                <button onclick="replayBoard()" class="px-6 py-3 bg-white/20 hover:bg-white/30 rounded-xl text-white font-bold transition-colors">Replay</button>
              ` : ''}
              <button onclick="backToMenu()" class="px-6 py-3 bg-white/20 hover:bg-white/30 rounded-xl text-white font-bold transition-colors">Menu</button>
            </div>
        `;
        
        // Leaderboard
        if (state.leaderboard.length > 0) {
          html += `
            <div class="bg-white/10 backdrop-blur rounded-2xl p-4 mt-4">
              <h3 class="text-white font-bold mb-2">Today's Leaderboard</h3>
              <div class="space-y-2">
          `;
          state.leaderboard.forEach((entry, i) => {
            const medal = i === 0 ? 'ðŸ¥‡' : i === 1 ? 'ðŸ¥ˆ' : i === 2 ? 'ðŸ¥‰' : '';
            html += `<div class="flex justify-between text-white"><span>${medal} ${entry.player}</span><span class="text-yellow-300">${entry.score} pts</span></div>`;
          });
          html += `</div></div>`;
        }
        
        html += `</div>`;
      }
      
      // Found words
      if (state.foundWords.length > 0) {
        const canRemove = state.practiceMode && state.gameState === 'finished';
        // Sort alphabetically in practice mode finished state, by score otherwise
        const sorted = canRemove
          ? [...state.foundWords].sort((a, b) => a.localeCompare(b))
          : [...state.foundWords].sort((a, b) => getWordScore(b) - getWordScore(a));
        html += `
          <div class="mt-4 bg-white/10 backdrop-blur rounded-2xl p-4">
            <h3 class="text-white font-bold mb-2">Found Words (${state.foundWords.length})${canRemove ? ' <span class="font-normal text-white/50 text-sm">- tap to remove</span>' : ''}</h3>
            <div class="flex flex-wrap gap-2">
              ${sorted.map(word => canRemove
                ? `<button onclick="removeWord('${word}')" class="bg-white/20 hover:bg-red-500/50 text-white px-2 py-1 rounded text-sm transition-colors">${word.toUpperCase()} <span class="text-yellow-300">+${getWordScore(word)}</span> <span class="text-red-300 ml-1">âœ•</span></button>`
                : `<span class="bg-white/20 text-white px-2 py-1 rounded text-sm">${word.toUpperCase()} <span class="text-yellow-300">+${getWordScore(word)}</span></span>`
              ).join('')}
            </div>
          </div>
        `;
      }
      
      // Scoring guide
      html += `<div class="mt-4 text-center text-green-200 text-xs"><p>3-4 letters: 1pt â€¢ 5: 2pts â€¢ 6: 3pts â€¢ 7: 5pts â€¢ 8+: 11pts</p></div>`;
      
      html += `</div>`;
      app.innerHTML = html;
      
      // Attach event listeners to tiles
      tileElements = Array.from(document.querySelectorAll('[data-index]'));
      tileElements.forEach(tile => {
        const index = parseInt(tile.dataset.index);
        // Swipe mode handlers
        tile.addEventListener('mousedown', (e) => handleDragStart(index, e));
        tile.addEventListener('touchstart', (e) => {
          if (state.inputMode === 'swipe') {
            handleDragStart(index, e);
          } else if (state.inputMode === 'tap') {
            handleTileTap(index, e);
          }
        }, { passive: false });
        // Click handler for tap mode (desktop)
        tile.addEventListener('click', (e) => handleTileTap(index, e));
      });
      
      // Type input listener
      const typeInput = document.getElementById('typeInput');
      if (typeInput) {
        typeInput.addEventListener('input', (e) => {
          state.typedWord = e.target.value.toLowerCase();
        });
        typeInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') submitWord();
        });
        typeInput.focus();
      }

      // Draw swipe lines after DOM is ready
      setTimeout(() => updateSwipeLines(), 0);
    }

    // Global event listeners
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
    document.addEventListener('mouseleave', handleDragEnd);
    document.addEventListener('touchmove', handleDragMove, { passive: false });
    document.addEventListener('touchend', handleDragEnd);
    document.addEventListener('touchcancel', handleDragEnd);

    // Make functions global
    window.handleLogin = handleLogin;
    window.startGame = startGame;
    window.startPracticeMode = startPracticeMode;
    window.newGame = newGame;
    window.backToMenu = backToMenu;
    window.submitWord = submitWord;
    window.clearSelection = clearSelection;
    window.setInputMode = setInputMode;
    window.shareResults = shareResults;
    window.loadBoardFromCode = loadBoardFromCode;
    window.copyPracticeCode = copyPracticeCode;
    window.generateRandomBoard = generateRandomBoard;
    window.replayBoard = replayBoard;
    window.removeWord = removeWord;
    // Multiplayer
    window.showMultiplayerMenu = showMultiplayerMenu;
    window.hostGame = hostGame;
    window.joinGame = joinGame;
    window.mpHostStartGame = mpHostStartGame;
    window.leaveRoom = leaveRoom;
    window.copyRoomCode = copyRoomCode;
    window.mpPlayAgain = mpPlayAgain;
    window.mpExit = mpExit;
    window.forceResults = forceResults;

    // Initial render
    render();
  </script>
</body>
</html>
