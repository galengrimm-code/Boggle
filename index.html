<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="application-name" content="Boggle">
  <meta name="apple-mobile-web-app-title" content="Boggle">
  <link rel="icon" type="image/svg+xml" href="icon.svg">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@600;700;800&display=swap" rel="stylesheet">
  <title>Daily Boggle</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>tailwind.config = { corePlugins: { preflight: true } }</script>
  <style>
    * { -webkit-tap-highlight-color: transparent; font-family: 'Nunito', sans-serif; }
    body { touch-action: manipulation; }
    .tile { touch-action: none; user-select: none; -webkit-user-select: none; cursor: pointer; }
    .tile-pop { animation: pop 0.15s ease-out; }
    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1.1); } }
    .tile-shake { animation: shake 0.4s ease-out; }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
    .tile-bounce { animation: bounce 0.5s ease-out; }
    @keyframes bounce { 0% { transform: scale(1); background: #4ade80; } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
    .float-points { position: fixed; animation: floatUp 1.5s ease-out forwards; pointer-events: none; font-weight: 800; font-size: 2.5rem; color: #fef08a; text-shadow: 0 0 10px #facc15, 0 0 20px #facc15, 0 3px 6px rgba(0,0,0,0.9); z-index: 1000; }
    @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(1.2); } 20% { opacity: 1; transform: translateY(-20px) scale(1.3); } 100% { opacity: 0; transform: translateY(-100px) scale(1.5); } }
    .timer-urgent { animation: pulse 0.5s ease-in-out infinite; color: #fca5a5 !important; }
    @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.05); } }
    .board-container { position: relative; }
    .swipe-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
    .swipe-line { stroke: rgba(250, 204, 21, 0.9); stroke-width: 6; stroke-linecap: round; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3)); }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-b from-blue-600 to-green-600">
  <div id="app"></div>

  <script src="words.js"></script>
  <script>
    // ============================================
    // CONFIGURATION - UPDATE THIS URL
    // ============================================
    const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxGQanlr2kHXtHL1MK59lymysbfvyerxuEd-XWA3XnQC4vkEKxnqR8mW0ti_m1g8K88hg/exec';
    // ============================================

    // Boggle dice
    const BOGGLE_DICE = [
      'AAEEGN', 'ABBJOO', 'ACHOPS', 'AFFKPS',
      'AOOTTW', 'CIMOTU', 'DEILRX', 'DELRVY',
      'DISTTY', 'EEGHNW', 'EEINSU', 'EHRTVW',
      'EIOSST', 'ELRTTY', 'HIMNQU', 'HLNNRZ'
    ];

    // Seeded random
    function seededRandom(seed) {
      const x = Math.sin(seed++) * 10000;
      return x - Math.floor(x);
    }

    // Generate daily board
    function generateDailyBoard(dateString) {
      const seed = dateString.split('-').join('') * 1;
      let currentSeed = seed;
      const shuffledDice = [...BOGGLE_DICE];
      for (let i = shuffledDice.length - 1; i > 0; i--) {
        const j = Math.floor(seededRandom(currentSeed++) * (i + 1));
        [shuffledDice[i], shuffledDice[j]] = [shuffledDice[j], shuffledDice[i]];
      }
      return shuffledDice.map(die => {
        const faceIndex = Math.floor(seededRandom(currentSeed++) * 6);
        let letter = die[faceIndex];
        return letter === 'Q' ? 'Qu' : letter;
      });
    }

    // Get today's date (local timezone - puzzle resets at local midnight)
    function getTodayString() {
      const now = new Date();
      return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
    }

    // Check adjacency
    function areAdjacent(pos1, pos2) {
      const row1 = Math.floor(pos1 / 4), col1 = pos1 % 4;
      const row2 = Math.floor(pos2 / 4), col2 = pos2 % 4;
      return Math.abs(row1 - row2) <= 1 && Math.abs(col1 - col2) <= 1 && pos1 !== pos2;
    }

    // Check if word can be formed
    function canFormWord(word, board) {
      const upperWord = word.toUpperCase();
      const boardUpper = board.map(l => l.toUpperCase());
      
      function search(wordIndex, position, used) {
        if (wordIndex >= upperWord.length) return true;
        const remaining = upperWord.slice(wordIndex);
        const letter = boardUpper[position];
        if (!remaining.startsWith(letter)) return false;
        const newUsed = new Set(used);
        newUsed.add(position);
        const nextIndex = wordIndex + letter.length;
        if (nextIndex >= upperWord.length) return true;
        for (let next = 0; next < 16; next++) {
          if (!newUsed.has(next) && areAdjacent(position, next)) {
            if (search(nextIndex, next, newUsed)) return true;
          }
        }
        return false;
      }
      
      for (let start = 0; start < 16; start++) {
        if (search(0, start, new Set())) return true;
      }
      return false;
    }

    // Score calculation
    function getWordScore(word) {
      const len = word.replace(/qu/gi, 'Q').length;
      if (len <= 2) return 0;
      if (len <= 4) return 1;
      if (len === 5) return 2;
      if (len === 6) return 3;
      if (len === 7) return 5;
      return 11;
    }

    
    // Show floating points animation
    function showFloatingPoints(points, x, y) {
      const el = document.createElement('div');
      el.className = 'float-points';
      el.textContent = '+' + points;
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1200);
    }

    // Animate tiles
    function animateTiles(indices, animClass) {
      indices.forEach(i => {
        const tile = document.querySelector('[data-index="' + i + '"]');
        if (tile) {
          tile.classList.remove('tile-pop', 'tile-shake', 'tile-bounce');
          void tile.offsetWidth; // trigger reflow
          tile.classList.add(animClass);
          setTimeout(() => tile.classList.remove(animClass), 500);
        }
      });
    }

    // Get tile center position
    function getTileCenter(index) {
      const tile = document.querySelector('[data-index="' + index + '"]');
      if (!tile) return { x: 0, y: 0 };
      const rect = tile.getBoundingClientRect();
      return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
    }

    // Dictionary loaded from words.js

    // Game state
    let state = {
      gameState: 'login', // login, ready, playing, finished
      board: [],
      selectedPath: [],
      currentWord: '',
      foundWords: [],
      timeLeft: 180,
      score: 0,
      message: '',
      todayDate: getTodayString(),
      playerName: localStorage.getItem('boggle_player') || '',
      inputMode: 'swipe',
      typedWord: '',
      isDragging: false,
      leaderboard: [],
      timerInterval: null,
      lastTouchTime: 0,
      lastTouchX: 0,
      lastTouchY: 0,
      pendingTile: null,
      pendingTimeout: null,
      possibleWords: null
    };

    // Initialize board
    state.board = generateDailyBoard(state.todayDate);

    // Tile refs
    let tileElements = [];

    // API calls
    async function checkPlayer(name) {
      try {
        const url = `${SCRIPT_URL}?action=check&player=${encodeURIComponent(name)}&date=${state.todayDate}`;
        const response = await fetch(url, { redirect: 'follow', mode: 'cors' });
        return await response.json();
      } catch (e) {
        console.error('API error:', e);
        return { played: false };
      }
    }

    async function saveScore(name, score, words) {
      try {
        const url = `${SCRIPT_URL}?action=save&player=${encodeURIComponent(name)}&date=${state.todayDate}&score=${score}&words=${words}`;
        await fetch(url, { redirect: 'follow', mode: 'cors' });
      } catch (e) {
        console.error('API error:', e);
      }
    }

    async function getLeaderboard() {
      try {
        const url = `${SCRIPT_URL}?action=leaderboard&date=${state.todayDate}`;
        const response = await fetch(url, { redirect: 'follow', mode: 'cors' });
        const data = await response.json();
        return data.leaderboard || [];
      } catch (e) {
        console.error('API error:', e);
        return [];
      }
    }

    // Get tile from point - improved for mobile
    function getTileFromPoint(x, y) {
      const el = document.elementFromPoint(x, y);
      if (el && el.dataset && el.dataset.index !== undefined) {
        return parseInt(el.dataset.index);
      }
      // Fallback to bounds checking
      for (let i = 0; i < tileElements.length; i++) {
        const rect = tileElements[i].getBoundingClientRect();
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          return i;
        }
      }
      return -1;
    }

    // Update tile visuals without full re-render
    function updateTileVisuals() {
      tileElements.forEach((tile, index) => {
        const isSelected = state.selectedPath.includes(index);
        const isLast = state.selectedPath[state.selectedPath.length - 1] === index;

        tile.className = 'aspect-square rounded-xl text-2xl font-bold transition-all duration-100 select-none tile ';
        if (isSelected) {
          tile.className += isLast ? 'bg-yellow-400 text-green-900 scale-110 shadow-lg ring-4 ring-yellow-300' : 'bg-teal-400 text-white';
        } else {
          tile.className += 'bg-white text-green-800';
        }
        if (state.gameState !== 'playing') tile.className += ' opacity-75';
      });

      // Update current word display
      const wordDisplay = document.getElementById('currentWordDisplay');
      if (wordDisplay) {
        wordDisplay.textContent = state.currentWord || (state.inputMode === 'swipe' ? 'Swipe letters...' : 'Tap letters...');
      }

      // Update swipe lines
      updateSwipeLines();
    }

    // Update swipe lines SVG
    function updateSwipeLines() {
      const svg = document.getElementById('swipeSvg');
      if (!svg) return;

      if (state.selectedPath.length > 1) {
        let lines = '';
        for (let i = 0; i < state.selectedPath.length - 1; i++) {
          const from = tileElements[state.selectedPath[i]];
          const to = tileElements[state.selectedPath[i + 1]];
          if (from && to) {
            const svgRect = svg.getBoundingClientRect();
            const fromRect = from.getBoundingClientRect();
            const toRect = to.getBoundingClientRect();
            const x1 = fromRect.left + fromRect.width / 2 - svgRect.left;
            const y1 = fromRect.top + fromRect.height / 2 - svgRect.top;
            const x2 = toRect.left + toRect.width / 2 - svgRect.left;
            const y2 = toRect.top + toRect.height / 2 - svgRect.top;
            lines += '<line class="swipe-line" x1="' + x1 + '" y1="' + y1 + '" x2="' + x2 + '" y2="' + y2 + '"/>';
          }
        }
        svg.innerHTML = lines;
      } else {
        svg.innerHTML = '';
      }
    }

    // Handle drag start
    function handleDragStart(index, e) {
      if (state.gameState !== 'playing' || state.inputMode !== 'swipe') return;
      e.preventDefault();
      e.stopPropagation();
      state.isDragging = true;
      state.lastTouchTime = Date.now();
      state.selectedPath = [index];
      state.currentWord = state.board[index];
      state.pendingTile = null;
      clearTimeout(state.pendingTimeout);
      // Set initial touch position
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      state.lastTouchX = clientX;
      state.lastTouchY = clientY;
      updateTileVisuals();
    }

    // Check if tile is diagonal from another
    function isDiagonal(pos1, pos2) {
      const row1 = Math.floor(pos1 / 4), col1 = pos1 % 4;
      const row2 = Math.floor(pos2 / 4), col2 = pos2 % 4;
      return Math.abs(row1 - row2) === 1 && Math.abs(col1 - col2) === 1;
    }

    // Get tile center position
    function getTileCenterPos(index) {
      const tile = tileElements[index];
      if (!tile) return null;
      const rect = tile.getBoundingClientRect();
      return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
    }

    // Handle drag move with diagonal preference
    function handleDragMove(e) {
      if (!state.isDragging || state.gameState !== 'playing' || state.inputMode !== 'swipe') return;
      e.preventDefault();

      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const index = getTileFromPoint(clientX, clientY);

      if (index === -1) return;

      const lastIndex = state.selectedPath[state.selectedPath.length - 1];

      // Backtracking
      if (state.selectedPath.length >= 2 && index === state.selectedPath[state.selectedPath.length - 2]) {
        clearTimeout(state.pendingTimeout);
        state.pendingTile = null;
        state.selectedPath = state.selectedPath.slice(0, -1);
        state.currentWord = state.selectedPath.map(i => state.board[i]).join('');
        updateTileVisuals();
        state.lastTouchX = clientX;
        state.lastTouchY = clientY;
        return;
      }

      // Skip if already selected or not adjacent
      if (state.selectedPath.includes(index) || !areAdjacent(lastIndex, index)) {
        state.lastTouchX = clientX;
        state.lastTouchY = clientY;
        return;
      }

      // Calculate swipe direction
      const dx = clientX - state.lastTouchX;
      const dy = clientY - state.lastTouchY;
      const swipeAngle = Math.abs(dx) > 0 || Math.abs(dy) > 0 ? Math.atan2(Math.abs(dy), Math.abs(dx)) : 0;
      const isDiagonalSwipe = swipeAngle > 0.3 && swipeAngle < 1.27; // ~17¬∞ to ~73¬∞

      // If this is an orthogonal tile but we're swiping diagonally, delay adding it
      const isTileDiagonal = isDiagonal(lastIndex, index);

      if (!isTileDiagonal && isDiagonalSwipe && Math.abs(dx) > 5 && Math.abs(dy) > 5) {
        // Check if there's a diagonal neighbor in our swipe direction
        const lastPos = getTileCenterPos(lastIndex);
        if (lastPos) {
          for (let i = 0; i < 16; i++) {
            if (!state.selectedPath.includes(i) && areAdjacent(lastIndex, i) && isDiagonal(lastIndex, i)) {
              const diagPos = getTileCenterPos(i);
              if (diagPos) {
                // Check if diagonal tile is in our swipe direction
                const toDiagX = diagPos.x - lastPos.x;
                const toDiagY = diagPos.y - lastPos.y;
                if ((dx > 0) === (toDiagX > 0) && (dy > 0) === (toDiagY > 0)) {
                  // We're swiping toward a diagonal - wait before adding orthogonal
                  state.pendingTile = index;
                  clearTimeout(state.pendingTimeout);
                  state.pendingTimeout = setTimeout(() => {
                    if (state.pendingTile === index && state.isDragging) {
                      addTileToPath(index);
                      state.pendingTile = null;
                    }
                  }, 80);
                  state.lastTouchX = clientX;
                  state.lastTouchY = clientY;
                  return;
                }
              }
            }
          }
        }
      }

      // Clear any pending tile if we're adding a different one
      if (state.pendingTile !== null && state.pendingTile !== index) {
        clearTimeout(state.pendingTimeout);
        state.pendingTile = null;
      }

      // Add tile immediately
      addTileToPath(index);
      state.lastTouchX = clientX;
      state.lastTouchY = clientY;
    }

    // Add tile to path helper
    function addTileToPath(index) {
      if (!state.selectedPath.includes(index) && areAdjacent(state.selectedPath[state.selectedPath.length - 1], index)) {
        state.selectedPath.push(index);
        state.currentWord = state.selectedPath.map(i => state.board[i]).join('');
        updateTileVisuals();
      }
    }

    // Handle drag end
    function handleDragEnd(e) {
      if (!state.isDragging) return;
      state.isDragging = false;
      state.lastTouchTime = Date.now();
      // Clear pending tile
      clearTimeout(state.pendingTimeout);
      state.pendingTile = null;
      if (state.selectedPath.length > 0 && state.currentWord.length >= 3) {
        submitWord();
      } else {
        clearSelection();
      }
    }

    // Handle tile tap (for tap mode)
    function handleTileTap(index, e) {
      // Prevent ghost clicks after touch
      if (e.type === 'click' && Date.now() - state.lastTouchTime < 500) {
        e.preventDefault();
        return;
      }

      if (state.gameState !== 'playing' || state.inputMode !== 'tap') return;

      if (e.type === 'touchstart') {
        e.preventDefault();
        state.lastTouchTime = Date.now();
      }

      if (state.selectedPath.length === 0) {
        state.selectedPath = [index];
        state.currentWord = state.board[index];
      } else if (state.selectedPath.includes(index)) {
        if (state.selectedPath[state.selectedPath.length - 1] === index && state.selectedPath.length > 1) {
          state.selectedPath = state.selectedPath.slice(0, -1);
          state.currentWord = state.selectedPath.map(i => state.board[i]).join('');
        } else if (state.selectedPath.length === 1) {
          state.selectedPath = [];
          state.currentWord = '';
        }
      } else if (areAdjacent(state.selectedPath[state.selectedPath.length - 1], index)) {
        state.selectedPath.push(index);
        state.currentWord += state.board[index];
      }
      updateTileVisuals();
    }

    // Clear selection
    function clearSelection() {
      state.selectedPath = [];
      state.currentWord = '';
      render();
    }

    // Submit word
    function submitWord() {
      const word = state.inputMode === 'type' ? state.typedWord.toLowerCase() : state.currentWord.toLowerCase();
      
      if (word.length < 3) {
        showMessage('Words must be at least 3 letters');
        clearSelection();
        state.typedWord = '';
        render();
        return;
      }
      
      if (state.foundWords.includes(word)) {
        animateTiles([...state.selectedPath], 'tile-shake'); showMessage('Already found!');
        clearSelection();
        state.typedWord = '';
        render();
        return;
      }
      
      if (!DICTIONARY.has(word)) {
        animateTiles([...state.selectedPath], 'tile-shake');
        clearSelection();
        state.typedWord = '';
        render();
        return;
      }
      
      if (state.inputMode === 'type' && !canFormWord(word, state.board)) {
        showMessage('Cannot form on board');
        state.typedWord = '';
        render();
        return;
      }
      
      const wordScore = getWordScore(word);
      const pathCopy = [...state.selectedPath];
      const lastTile = getTileCenter(pathCopy[pathCopy.length - 1] || 0);

      state.foundWords.push(word);
      state.score += wordScore;

      // Quick visual updates
      showFloatingPoints(wordScore, lastTile.x - 20, lastTile.y - 20);
      animateTiles(pathCopy, 'tile-bounce');
      updateScoreDisplay();

      // Clear and update
      state.selectedPath = [];
      state.currentWord = '';
      state.typedWord = '';
      updateTileVisuals();

      // Full render to update found words list
      render();
    }

    // Quick score update without full render
    function updateScoreDisplay() {
      const scoreEl = document.getElementById('scoreDisplay');
      if (scoreEl) scoreEl.textContent = state.score + ' pts';
    }

    // Show message
    function showMessage(msg) {
      state.message = msg;
      // Update message element directly if it exists
      const msgEl = document.getElementById('messageDisplay');
      if (msgEl) {
        msgEl.innerHTML = msg ? `<span class="bg-white/20 text-white px-4 py-2 rounded-full font-medium">${msg}</span>` : '';
        return;
      }
      render();
      setTimeout(() => {
        state.message = '';
        render();
      }, 1500);
    }

    // Format time
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Share results
    function shareResults() {
      // Find longest word (count Qu as 1 letter)
      let longestWord = '';
      state.foundWords.forEach(word => {
        const len = word.replace(/qu/gi, 'Q').length;
        const longestLen = longestWord.replace(/qu/gi, 'Q').length;
        if (len > longestLen) longestWord = word;
      });
      const longestLen = longestWord ? longestWord.replace(/qu/gi, 'Q').length : 0;

      // Score emoji based on performance
      let scoreEmoji = 'üéØ';
      if (state.score >= 100) scoreEmoji = 'üèÜ';
      else if (state.score >= 50) scoreEmoji = 'üî•';
      else if (state.score >= 25) scoreEmoji = '‚≠ê';

      // Word length stars
      const stars = '‚¨õ'.repeat(Math.min(longestLen, 8));

      const shareText = `üé≤ Daily Boggle üé≤\nüìÖ ${state.todayDate}\n${scoreEmoji} ${state.score} points\nüìè Longest: ${longestLen} letters\n${stars}`;

      if (navigator.share) {
        navigator.share({ text: shareText }).catch(() => copyToClipboard(shareText));
      } else {
        copyToClipboard(shareText);
      }
    }

    // Copy to clipboard
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text);
      showMessage('Copied to clipboard!');
    }

    // Calculate all possible words on the board
    function getAllPossibleWords() {
      const possibleWords = [];
      DICTIONARY.forEach(word => {
        if (word.length >= 3 && canFormWord(word, state.board)) {
          possibleWords.push(word);
        }
      });
      return possibleWords;
    }

    // Login
    async function handleLogin() {
      const nameInput = document.getElementById('playerName');
      const name = nameInput.value.trim().toLowerCase();
      if (!name) return;

      state.playerName = name;
      localStorage.setItem('boggle_player', name);

      // Show loading state immediately
      const btn = document.querySelector('button[onclick="handleLogin()"]');
      if (btn) btn.textContent = 'Loading...';

      // Run API calls in parallel with timeout
      const timeout = (ms) => new Promise((_, reject) => setTimeout(() => reject('timeout'), ms));

      try {
        const [check, leaderboard] = await Promise.all([
          Promise.race([checkPlayer(name), timeout(3000)]).catch(() => ({ played: false })),
          Promise.race([getLeaderboard(), timeout(3000)]).catch(() => [])
        ]);

        state.leaderboard = leaderboard;

        if (check.played) {
          state.score = check.score;
          state.foundWords = [];
          state.gameState = 'finished';
          showMessage("You've already played today!");
        } else {
          state.gameState = 'ready';
        }
      } catch (e) {
        // If API fails, just let them play
        state.gameState = 'ready';
      }

      render();
    }

    // Start game
    function startGame() {
      state.gameState = 'playing';
      state.foundWords = [];
      state.score = 0;
      state.timeLeft = 180;
      state.message = '';
      
      state.timerInterval = setInterval(() => {
        state.timeLeft--;
        if (state.timeLeft <= 0) {
          endGame();
        } else {
          // Quick timer update without full render
          const timerEl = document.getElementById('timerDisplay');
          if (timerEl) {
            timerEl.textContent = '‚è± ' + formatTime(state.timeLeft);
            timerEl.className = 'text-2xl font-mono font-bold ' + (state.timeLeft <= 30 ? 'text-red-300 timer-urgent' : 'text-white');
          }
        }
      }, 1000);
      
      render();
    }

    // End game
    async function endGame() {
      clearInterval(state.timerInterval);
      state.gameState = 'finished';
      clearSelection();

      // Haptic buzz on game end
      if (navigator.vibrate) navigator.vibrate([100, 50, 100]);

      // Render finished state immediately, don't wait for API
      render();

      // Calculate possible words in background
      setTimeout(() => {
        state.possibleWords = getAllPossibleWords();
        render();
      }, 100);

      // Save score and get leaderboard in background
      try {
        await saveScore(state.playerName, state.score, state.foundWords.length);
        state.leaderboard = await getLeaderboard();
        render(); // Re-render with leaderboard
      } catch (e) {
        console.error('Error saving score:', e);
      }
    }

    // Set input mode
    function setInputMode(mode) {
      state.inputMode = mode;
      state.typedWord = '';
      clearSelection();
    }

    // Render
    function render() {
      const app = document.getElementById('app');
      
      // Login screen
      if (state.gameState === 'login') {
        app.innerHTML = `
          <div class="min-h-screen flex items-center justify-center p-4">
            <div class="bg-white/10 backdrop-blur rounded-2xl p-8 max-w-sm w-full text-center">
              <h1 class="text-3xl font-bold text-white mb-2">Daily Boggle</h1>
              <p class="text-blue-100 mb-6">${state.todayDate}</p>
              <input 
                type="text" 
                id="playerName" 
                placeholder="Enter your name"
                value="${state.playerName}"
                class="w-full px-4 py-3 rounded-xl text-lg text-center outline-none mb-4"
                onkeypress="if(event.key==='Enter')handleLogin()"
              />
              <button 
                onclick="handleLogin()"
                class="w-full px-6 py-3 bg-green-500 hover:bg-green-400 rounded-xl text-white text-lg font-bold transition-colors"
              >
                Play
              </button>
            </div>
          </div>
        `;
        return;
      }

      let html = `<div class="max-w-md mx-auto p-4">`;
      
      // Header
      html += `
        <div class="text-center mb-4">
          <h1 class="text-3xl font-bold text-white mb-1">Daily Boggle</h1>
          <p class="text-blue-100 text-sm">${state.todayDate} ‚Ä¢ ${state.playerName}</p>
        </div>
      `;
      
      // Timer and Score (playing)
      if (state.gameState === 'playing') {
        html += `
          <div class="flex justify-between items-center mb-4 px-2">
            <div id="timerDisplay" class="text-2xl font-mono font-bold ${state.timeLeft <= 30 ? 'text-red-300 timer-urgent' : 'text-white'}">
              ‚è± ${formatTime(state.timeLeft)}
            </div>
            <div id="scoreDisplay" class="text-2xl font-bold text-yellow-300">${state.score} pts</div>
          </div>
        `;
      }

      // Game Board (only show during playing and finished)
      if (state.gameState === 'playing' || state.gameState === 'finished') {
        html += `<div class="bg-white/10 backdrop-blur rounded-2xl p-4 mb-4 select-none board-container"><svg class="swipe-svg" id="swipeSvg"></svg><div class="grid grid-cols-4 gap-2">`;

        state.board.forEach((letter, index) => {
          const isSelected = state.selectedPath.includes(index);
          const isLast = state.selectedPath[state.selectedPath.length - 1] === index;

          let tileClass = 'aspect-square rounded-xl text-2xl font-bold transition-all duration-100 select-none tile ';
          if (isSelected) {
            tileClass += isLast ? 'bg-yellow-400 text-green-900 scale-110 shadow-lg ring-4 ring-yellow-300' : 'bg-teal-400 text-white';
          } else {
            tileClass += 'bg-white text-green-800';
          }
          if (state.gameState !== 'playing') tileClass += ' opacity-75';

          html += `<button class="${tileClass}" data-index="${index}">${letter}</button>`;
        });

        html += `</div></div>`;
      }
      
      // Input area (playing)
      if (state.gameState === 'playing') {
        html += `
          <div class="mb-4">
            <div class="flex justify-center gap-2 mb-3">
              <button onclick="setInputMode('swipe')" class="px-4 py-1 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'swipe' ? 'bg-white text-green-800' : 'bg-white/20 text-white'}">Swipe</button>
              <button onclick="setInputMode('tap')" class="px-4 py-1 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'tap' ? 'bg-white text-green-800' : 'bg-white/20 text-white'}">Tap</button>
              <button onclick="setInputMode('type')" class="px-4 py-1 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'type' ? 'bg-white text-green-800' : 'bg-white/20 text-white'}">Type</button>
            </div>
        `;
        
        if (state.inputMode === 'type') {
          html += `
            <div class="flex gap-2">
              <input type="text" id="typeInput" value="${state.typedWord}" placeholder="Type a word..." 
                class="flex-1 bg-white/20 rounded-xl px-4 py-3 text-white text-xl font-bold placeholder-white/50 outline-none focus:bg-white/30"
                autocomplete="off" autocapitalize="off" />
              <button onclick="submitWord()" class="px-6 bg-green-500 hover:bg-green-400 disabled:bg-gray-500 disabled:opacity-50 rounded-xl text-white font-bold transition-colors">‚úì</button>
            </div>
          `;
        } else {
          html += `
            <div class="flex gap-2">
              <div class="flex-1 bg-white/20 rounded-xl px-4 py-3 text-center min-h-[52px] flex items-center justify-center">
                <span id="currentWordDisplay" class="text-2xl font-bold text-white tracking-wider">${state.currentWord || (state.inputMode === 'swipe' ? 'Swipe letters...' : 'Tap letters...')}</span>
              </div>
              ${state.inputMode === 'tap' ? `
                <button onclick="submitWord()" class="px-6 bg-green-500 hover:bg-green-400 rounded-xl text-white font-bold transition-colors">‚úì</button>
                <button onclick="clearSelection()" class="px-4 bg-red-500 hover:bg-red-400 rounded-xl text-white font-bold transition-colors">‚úï</button>
              ` : ''}
            </div>
          `;
        }
        html += `</div>`;
      }
      
      // Message (always render container for quick updates)
      html += `<div id="messageDisplay" class="text-center mb-4">${state.message ? `<span class="bg-white/20 text-white px-4 py-2 rounded-full font-medium">${state.message}</span>` : ''}</div>`;
      
      // Ready state
      if (state.gameState === 'ready') {
        html += `
          <div class="bg-white/10 backdrop-blur rounded-2xl p-6 mb-4">
            <p class="text-green-100 text-center mb-6">Find as many words as you can in 3 minutes!<br/>Select adjacent letters to form words.</p>

            <div class="mb-6">
              <p class="text-white/70 text-sm text-center mb-3">Input Method</p>
              <div class="flex justify-center gap-2">
                <button onclick="setInputMode('swipe')" class="px-5 py-2 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'swipe' ? 'bg-white text-green-800' : 'bg-white/20 text-white hover:bg-white/30'}">Swipe</button>
                <button onclick="setInputMode('tap')" class="px-5 py-2 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'tap' ? 'bg-white text-green-800' : 'bg-white/20 text-white hover:bg-white/30'}">Tap</button>
                <button onclick="setInputMode('type')" class="px-5 py-2 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'type' ? 'bg-white text-green-800' : 'bg-white/20 text-white hover:bg-white/30'}">Type</button>
              </div>
            </div>

            <div class="text-center">
              <button onclick="startGame()" class="px-8 py-4 bg-green-500 hover:bg-green-400 rounded-2xl text-white text-xl font-bold transition-colors shadow-lg">Start Game</button>
            </div>
          </div>
        `;
      }
      
      // Finished state
      if (state.gameState === 'finished') {
        const possibleCount = state.possibleWords ? state.possibleWords.length : null;
        const percentFound = possibleCount ? Math.round((state.foundWords.length / possibleCount) * 100) : null;

        // Score message
        let scoreMessage = '';
        if (state.score <= 10) scoreMessage = 'Words may not be your thing!';
        else if (state.score <= 15) scoreMessage = 'Not bad!';
        else if (state.score <= 20) scoreMessage = 'Good job!';
        else scoreMessage = 'You did really good!';

        html += `
          <div class="text-center">
            <div class="bg-white/10 backdrop-blur rounded-2xl p-6 mb-4">
              <h2 class="text-xl font-bold text-white mb-2">${state.foundWords.length > 0 ? "Time's Up!" : "Today's Results"}</h2>
              <div class="text-4xl font-bold text-yellow-300 mb-2">${state.score} pts</div>
              <p class="text-white text-lg mb-1">${scoreMessage}</p>
              <p class="text-green-100">${state.foundWords.length} words found</p>
              <p class="text-green-200 text-sm mt-2">
                ${possibleCount !== null
                  ? `üìä ${possibleCount} possible words (you found ${percentFound}%)`
                  : 'üìä Calculating possible words...'}
              </p>
            </div>
            <button onclick="shareResults()" class="px-6 py-3 bg-blue-500 hover:bg-blue-400 rounded-xl text-white font-bold transition-colors mb-4">Share Results</button>
        `;
        
        // Leaderboard
        if (state.leaderboard.length > 0) {
          html += `
            <div class="bg-white/10 backdrop-blur rounded-2xl p-4 mt-4">
              <h3 class="text-white font-bold mb-2">Today's Leaderboard</h3>
              <div class="space-y-2">
          `;
          state.leaderboard.forEach((entry, i) => {
            const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
            html += `<div class="flex justify-between text-white"><span>${medal} ${entry.player}</span><span class="text-yellow-300">${entry.score} pts</span></div>`;
          });
          html += `</div></div>`;
        }
        
        html += `</div>`;
      }
      
      // Found words
      if (state.foundWords.length > 0) {
        const sorted = [...state.foundWords].sort((a, b) => getWordScore(b) - getWordScore(a));
        html += `
          <div class="mt-4 bg-white/10 backdrop-blur rounded-2xl p-4">
            <h3 class="text-white font-bold mb-2">Found Words (${state.foundWords.length})</h3>
            <div class="flex flex-wrap gap-2">
              ${sorted.map(word => `<span class="bg-white/20 text-white px-2 py-1 rounded text-sm">${word.toUpperCase()} <span class="text-yellow-300">+${getWordScore(word)}</span></span>`).join('')}
            </div>
          </div>
        `;
      }
      
      // Scoring guide
      html += `<div class="mt-4 text-center text-green-200 text-xs"><p>3-4 letters: 1pt ‚Ä¢ 5: 2pts ‚Ä¢ 6: 3pts ‚Ä¢ 7: 5pts ‚Ä¢ 8+: 11pts</p></div>`;
      
      html += `</div>`;
      app.innerHTML = html;
      
      // Attach event listeners to tiles
      tileElements = Array.from(document.querySelectorAll('[data-index]'));
      tileElements.forEach(tile => {
        const index = parseInt(tile.dataset.index);
        // Swipe mode handlers
        tile.addEventListener('mousedown', (e) => handleDragStart(index, e));
        tile.addEventListener('touchstart', (e) => {
          if (state.inputMode === 'swipe') {
            handleDragStart(index, e);
          } else if (state.inputMode === 'tap') {
            handleTileTap(index, e);
          }
        }, { passive: false });
        // Click handler for tap mode (desktop)
        tile.addEventListener('click', (e) => handleTileTap(index, e));
      });
      
      // Type input listener
      const typeInput = document.getElementById('typeInput');
      if (typeInput) {
        typeInput.addEventListener('input', (e) => {
          state.typedWord = e.target.value.toLowerCase();
        });
        typeInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') submitWord();
        });
        typeInput.focus();
      }

      // Draw swipe lines after DOM is ready
      setTimeout(() => updateSwipeLines(), 0);
    }

    // Global event listeners
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
    document.addEventListener('mouseleave', handleDragEnd);
    document.addEventListener('touchmove', handleDragMove, { passive: false });
    document.addEventListener('touchend', handleDragEnd);
    document.addEventListener('touchcancel', handleDragEnd);

    // Make functions global
    window.handleLogin = handleLogin;
    window.startGame = startGame;
    window.submitWord = submitWord;
    window.clearSelection = clearSelection;
    window.setInputMode = setInputMode;
    window.shareResults = shareResults;

    // Initial render
    render();
  </script>
</body>
</html>
