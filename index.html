<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="application-name" content="Boggle">
  <meta name="apple-mobile-web-app-title" content="Boggle">
  <link rel="icon" type="image/svg+xml" href="icon.svg">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@600;700;800&display=swap" rel="stylesheet">
  <title>Daily Boggle</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>tailwind.config = { corePlugins: { preflight: true } }</script>
  <style>
    * { -webkit-tap-highlight-color: transparent; font-family: 'Nunito', sans-serif; box-sizing: border-box; }
    html, body {
      touch-action: manipulation;
      overscroll-behavior: none;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
    }
    body { min-height: 100vh; min-height: -webkit-fill-available; }
    #app {
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
    }
    .tile { touch-action: none; user-select: none; -webkit-user-select: none; cursor: pointer; will-change: transform, background-color; }
    .tile-pop { animation: pop 0.15s ease-out; }
    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1.1); } }
    .tile-shake { animation: shake 0.4s ease-out; }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
    .tile-bounce { animation: bounce 0.5s ease-out; }
    @keyframes bounce { 0% { transform: scale(1); background: #4ade80; } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
    .float-points { position: fixed; animation: floatUp 1.5s ease-out forwards; pointer-events: none; font-weight: 800; font-size: 2.5rem; color: #fef08a; text-shadow: 0 0 10px #facc15, 0 0 20px #facc15, 0 3px 6px rgba(0,0,0,0.9); z-index: 1000; }
    @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(1.2); } 20% { opacity: 1; transform: translateY(-20px) scale(1.3); } 100% { opacity: 0; transform: translateY(-100px) scale(1.5); } }
    .timer-urgent { animation: pulse 0.5s ease-in-out infinite; color: #fca5a5 !important; }
    @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.05); } }
    .board-container { position: relative; }
    .swipe-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
    .swipe-line { stroke: rgba(250, 204, 21, 0.9); stroke-width: 6; stroke-linecap: round; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3)); }
    button { -webkit-appearance: none; appearance: none; }
    input { -webkit-appearance: none; appearance: none; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-b from-blue-600 to-green-600">
  <div id="app"></div>

  <script src="words.js"></script>
  <script>
    // ============================================
    // CONFIGURATION - UPDATE THIS URL
    // ============================================
    const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxGQanlr2kHXtHL1MK59lymysbfvyerxuEd-XWA3XnQC4vkEKxnqR8mW0ti_m1g8K88hg/exec';
    // ============================================

    // Boggle dice
    const BOGGLE_DICE = [
      'AAEEGN', 'ABBJOO', 'ACHOPS', 'AFFKPS',
      'AOOTTW', 'CIMOTU', 'DEILRX', 'DELRVY',
      'DISTTY', 'EEGHNW', 'EEINSU', 'EHRTVW',
      'EIOSST', 'ELRTTY', 'HIMNQU', 'HLNNRZ'
    ];

    // Seeded random
    function seededRandom(seed) {
      const x = Math.sin(seed++) * 10000;
      return x - Math.floor(x);
    }

    // Generate daily board
    function generateDailyBoard(dateString) {
      const seed = dateString.split('-').join('') * 1;
      let currentSeed = seed;
      const shuffledDice = [...BOGGLE_DICE];
      for (let i = shuffledDice.length - 1; i > 0; i--) {
        const j = Math.floor(seededRandom(currentSeed++) * (i + 1));
        [shuffledDice[i], shuffledDice[j]] = [shuffledDice[j], shuffledDice[i]];
      }
      return shuffledDice.map(die => {
        const faceIndex = Math.floor(seededRandom(currentSeed++) * 6);
        let letter = die[faceIndex];
        return letter === 'Q' ? 'Qu' : letter;
      });
    }

    // Generate board from seed (for practice mode sharing)
    function generateSeededBoard(seed) {
      let currentSeed = seed;
      const shuffledDice = [...BOGGLE_DICE];
      for (let i = shuffledDice.length - 1; i > 0; i--) {
        const j = Math.floor(seededRandom(currentSeed++) * (i + 1));
        [shuffledDice[i], shuffledDice[j]] = [shuffledDice[j], shuffledDice[i]];
      }
      return shuffledDice.map(die => {
        const faceIndex = Math.floor(seededRandom(currentSeed++) * 6);
        let letter = die[faceIndex];
        return letter === 'Q' ? 'Qu' : letter;
      });
    }

    // Generate random 5-digit code
    function generatePracticeCode() {
      return Math.floor(10000 + Math.random() * 90000);
    }

    // Validate board meets quality criteria
    function validateBoard(board) {
      // Count vowels (A, E, I, O, U)
      const vowels = 'AEIOU';
      let vowelCount = 0;
      const letterCounts = {};

      board.forEach(letter => {
        const l = letter.toUpperCase().charAt(0);
        if (vowels.includes(l)) vowelCount++;
        letterCounts[l] = (letterCounts[l] || 0) + 1;
      });

      // Check minimum 4 vowels
      if (vowelCount < 4) return false;

      // Check no more than 2 duplicate letters (letters appearing 2+ times)
      let duplicateCount = 0;
      for (const count of Object.values(letterCounts)) {
        if (count >= 2) duplicateCount++;
      }
      if (duplicateCount > 2) return false;

      return true;
    }

    // Generate random board (for practice mode)
    function generateRandomBoard() {
      let code, board;
      let attempts = 0;
      const maxAttempts = 100;

      do {
        code = generatePracticeCode();
        board = generateSeededBoard(code);
        attempts++;
      } while (!validateBoard(board) && attempts < maxAttempts);

      state.practiceCode = code;
      return board;
    }

    // Get today's date (local timezone - puzzle resets at local midnight)
    function getTodayString() {
      const now = new Date();
      return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
    }

    // Check adjacency
    function areAdjacent(pos1, pos2) {
      const row1 = Math.floor(pos1 / 4), col1 = pos1 % 4;
      const row2 = Math.floor(pos2 / 4), col2 = pos2 % 4;
      return Math.abs(row1 - row2) <= 1 && Math.abs(col1 - col2) <= 1 && pos1 !== pos2;
    }

    // Check if word can be formed
    function canFormWord(word, board) {
      const upperWord = word.toUpperCase();
      const boardUpper = board.map(l => l.toUpperCase());
      
      function search(wordIndex, position, used) {
        if (wordIndex >= upperWord.length) return true;
        const remaining = upperWord.slice(wordIndex);
        const letter = boardUpper[position];
        if (!remaining.startsWith(letter)) return false;
        const newUsed = new Set(used);
        newUsed.add(position);
        const nextIndex = wordIndex + letter.length;
        if (nextIndex >= upperWord.length) return true;
        for (let next = 0; next < 16; next++) {
          if (!newUsed.has(next) && areAdjacent(position, next)) {
            if (search(nextIndex, next, newUsed)) return true;
          }
        }
        return false;
      }
      
      for (let start = 0; start < 16; start++) {
        if (search(0, start, new Set())) return true;
      }
      return false;
    }

    // Score calculation
    function getWordScore(word) {
      const len = word.replace(/qu/gi, 'Q').length;
      if (len <= 2) return 0;
      if (len <= 4) return 1;
      if (len === 5) return 2;
      if (len === 6) return 3;
      if (len === 7) return 5;
      return 11;
    }

    
    // Show floating points animation
    function showFloatingPoints(points, x, y) {
      const el = document.createElement('div');
      el.className = 'float-points';
      el.textContent = '+' + points;
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1200);
    }

    // Animate tiles
    function animateTiles(indices, animClass) {
      indices.forEach(i => {
        const tile = document.querySelector('[data-index="' + i + '"]');
        if (tile) {
          tile.classList.remove('tile-pop', 'tile-shake', 'tile-bounce');
          void tile.offsetWidth; // trigger reflow
          tile.classList.add(animClass);
          setTimeout(() => tile.classList.remove(animClass), 500);
        }
      });
    }

    // Get tile center position
    function getTileCenter(index) {
      const tile = document.querySelector('[data-index="' + index + '"]');
      if (!tile) return { x: 0, y: 0 };
      const rect = tile.getBoundingClientRect();
      return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
    }

    // Dictionary loaded from words.js

    // Game state
    let state = {
      gameState: 'login', // login, ready, playing, finished
      board: [],
      selectedPath: [],
      currentWord: '',
      foundWords: [],
      timeLeft: 180,
      score: 0,
      message: '',
      todayDate: getTodayString(),
      playerName: localStorage.getItem('boggle_player') || '',
      inputMode: 'swipe',
      typedWord: '',
      isDragging: false,
      leaderboard: [],
      timerInterval: null,
      lastTouchTime: 0,
      lastTouchX: 0,
      lastTouchY: 0,
      pendingTile: null,
      pendingTimeout: null,
      possibleWords: null,
      practiceMode: false,
      practiceCode: null,
      // Multiplayer
      multiplayerMode: false,
      roomId: null,
      isHost: false,
      roomPlayers: [],
      roomStatus: null,
      pollInterval: null,
      mpResults: null,
      mpStartTime: null,
      mpSubmitted: false,
      countdownInterval: null
    };

    // Initialize board
    state.board = generateDailyBoard(state.todayDate);

    // Tile refs
    let tileElements = [];

    // API calls
    async function checkPlayer(name) {
      try {
        const url = `${SCRIPT_URL}?action=check&player=${encodeURIComponent(name)}&date=${state.todayDate}`;
        const response = await fetch(url, { redirect: 'follow', mode: 'cors' });
        return await response.json();
      } catch (e) {
        console.error('API error:', e);
        return { played: false };
      }
    }

    async function saveScore(name, score, words) {
      try {
        const url = `${SCRIPT_URL}?action=save&player=${encodeURIComponent(name)}&date=${state.todayDate}&score=${score}&words=${words}`;
        await fetch(url, { redirect: 'follow', mode: 'cors' });
      } catch (e) {
        console.error('API error:', e);
      }
    }

    async function getLeaderboard() {
      try {
        const url = `${SCRIPT_URL}?action=leaderboard&date=${state.todayDate}`;
        const response = await fetch(url, { redirect: 'follow', mode: 'cors' });
        const data = await response.json();
        return data.leaderboard || [];
      } catch (e) {
        console.error('API error:', e);
        return [];
      }
    }

    // ============================================
    // MULTIPLAYER API FUNCTIONS
    // ============================================

    async function mpCreateRoom(player, boardCode) {
      try {
        const url = `${SCRIPT_URL}?action=createRoom&player=${encodeURIComponent(player)}&boardCode=${boardCode}`;
        const response = await fetch(url, { redirect: 'follow', mode: 'cors' });
        return await response.json();
      } catch (e) {
        console.error('API error:', e);
        return { error: 'Network error' };
      }
    }

    async function mpJoinRoom(roomId, player) {
      try {
        const url = `${SCRIPT_URL}?action=joinRoom&roomId=${encodeURIComponent(roomId)}&player=${encodeURIComponent(player)}`;
        const response = await fetch(url, { redirect: 'follow', mode: 'cors' });
        return await response.json();
      } catch (e) {
        console.error('API error:', e);
        return { error: 'Network error' };
      }
    }

    async function mpPollRoom(roomId) {
      try {
        const url = `${SCRIPT_URL}?action=pollRoom&roomId=${encodeURIComponent(roomId)}`;
        const response = await fetch(url, { redirect: 'follow', mode: 'cors' });
        return await response.json();
      } catch (e) {
        console.error('API error:', e);
        return { error: 'Network error' };
      }
    }

    async function mpStartRoom(roomId) {
      try {
        const url = `${SCRIPT_URL}?action=startRoom&roomId=${encodeURIComponent(roomId)}`;
        const response = await fetch(url, { redirect: 'follow', mode: 'cors' });
        return await response.json();
      } catch (e) {
        console.error('API error:', e);
        return { error: 'Network error' };
      }
    }

    async function mpSubmitWords(roomId, player, words) {
      try {
        const wordsStr = words.join(',');
        const url = `${SCRIPT_URL}?action=submitWords&roomId=${encodeURIComponent(roomId)}&player=${encodeURIComponent(player)}&words=${encodeURIComponent(wordsStr)}`;
        const response = await fetch(url, { redirect: 'follow', mode: 'cors' });
        return await response.json();
      } catch (e) {
        console.error('API error:', e);
        return { error: 'Network error' };
      }
    }

    async function mpGetResults(roomId) {
      try {
        const url = `${SCRIPT_URL}?action=getResults&roomId=${encodeURIComponent(roomId)}`;
        const response = await fetch(url, { redirect: 'follow', mode: 'cors' });
        return await response.json();
      } catch (e) {
        console.error('API error:', e);
        return { error: 'Network error' };
      }
    }

    async function mpLeaveRoom(roomId, player) {
      try {
        const url = `${SCRIPT_URL}?action=leaveRoom&roomId=${encodeURIComponent(roomId)}&player=${encodeURIComponent(player)}`;
        await fetch(url, { redirect: 'follow', mode: 'cors' });
      } catch (e) {
        console.error('API error:', e);
      }
    }

    // Get tile from point - improved for mobile with expanded hit detection
    function getTileFromPoint(x, y) {
      // First try exact hit
      const el = document.elementFromPoint(x, y);
      if (el && el.dataset && el.dataset.index !== undefined) {
        return parseInt(el.dataset.index);
      }

      // Fallback: find nearest tile within expanded touch radius
      let nearestIndex = -1;
      let nearestDist = Infinity;
      const touchRadius = 25; // pixels of tolerance around tile edges

      for (let i = 0; i < tileElements.length; i++) {
        const rect = tileElements[i].getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        // Check if within expanded bounds (tile + tolerance)
        const expandedLeft = rect.left - touchRadius;
        const expandedRight = rect.right + touchRadius;
        const expandedTop = rect.top - touchRadius;
        const expandedBottom = rect.bottom + touchRadius;

        if (x >= expandedLeft && x <= expandedRight && y >= expandedTop && y <= expandedBottom) {
          // Calculate distance to tile center
          const dist = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestIndex = i;
          }
        }
      }

      return nearestIndex;
    }

    // Update tile visuals without full re-render
    function updateTileVisuals() {
      tileElements.forEach((tile, index) => {
        const isSelected = state.selectedPath.includes(index);
        const isLast = state.selectedPath[state.selectedPath.length - 1] === index;

        tile.className = 'aspect-square rounded-xl text-2xl font-bold transition-all duration-100 select-none tile ';
        if (isSelected) {
          tile.className += isLast ? 'bg-yellow-400 text-green-900 scale-110 shadow-lg ring-4 ring-yellow-300' : 'bg-teal-400 text-white';
        } else {
          tile.className += 'bg-white text-green-800';
        }
        if (state.gameState !== 'playing') tile.className += ' opacity-75';
      });

      // Update current word display
      const wordDisplay = document.getElementById('currentWordDisplay');
      if (wordDisplay) {
        wordDisplay.textContent = state.currentWord || (state.inputMode === 'swipe' ? 'Swipe letters...' : 'Tap letters...');
      }

      // Update swipe lines
      updateSwipeLines();
    }

    // Update swipe lines SVG
    function updateSwipeLines() {
      const svg = document.getElementById('swipeSvg');
      if (!svg) return;

      if (state.selectedPath.length > 1) {
        let lines = '';
        for (let i = 0; i < state.selectedPath.length - 1; i++) {
          const from = tileElements[state.selectedPath[i]];
          const to = tileElements[state.selectedPath[i + 1]];
          if (from && to) {
            const svgRect = svg.getBoundingClientRect();
            const fromRect = from.getBoundingClientRect();
            const toRect = to.getBoundingClientRect();
            const x1 = fromRect.left + fromRect.width / 2 - svgRect.left;
            const y1 = fromRect.top + fromRect.height / 2 - svgRect.top;
            const x2 = toRect.left + toRect.width / 2 - svgRect.left;
            const y2 = toRect.top + toRect.height / 2 - svgRect.top;
            lines += '<line class="swipe-line" x1="' + x1 + '" y1="' + y1 + '" x2="' + x2 + '" y2="' + y2 + '"/>';
          }
        }
        svg.innerHTML = lines;
      } else {
        svg.innerHTML = '';
      }
    }

    // Handle drag start
    function handleDragStart(index, e) {
      if (state.gameState !== 'playing' || state.inputMode !== 'swipe') return;
      e.preventDefault();
      e.stopPropagation();
      state.isDragging = true;
      state.lastTouchTime = Date.now();
      state.selectedPath = [index];
      state.currentWord = state.board[index];
      state.pendingTile = null;
      clearTimeout(state.pendingTimeout);
      // Set initial touch position
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      state.lastTouchX = clientX;
      state.lastTouchY = clientY;
      updateTileVisuals();
    }

    // Check if tile is diagonal from another
    function isDiagonal(pos1, pos2) {
      const row1 = Math.floor(pos1 / 4), col1 = pos1 % 4;
      const row2 = Math.floor(pos2 / 4), col2 = pos2 % 4;
      return Math.abs(row1 - row2) === 1 && Math.abs(col1 - col2) === 1;
    }

    // Get tile center position
    function getTileCenterPos(index) {
      const tile = tileElements[index];
      if (!tile) return null;
      const rect = tile.getBoundingClientRect();
      return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
    }

    // Handle drag move - simplified and reliable
    function handleDragMove(e) {
      if (!state.isDragging || state.gameState !== 'playing' || state.inputMode !== 'swipe') return;
      e.preventDefault();

      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;

      const lastIndex = state.selectedPath[state.selectedPath.length - 1];

      // First, check what tile is directly under the touch
      const touchedIndex = getTileFromPoint(clientX, clientY);

      // Handle backtracking - if touching the previous tile
      if (state.selectedPath.length >= 2 && touchedIndex === state.selectedPath[state.selectedPath.length - 2]) {
        state.selectedPath = state.selectedPath.slice(0, -1);
        state.currentWord = state.selectedPath.map(i => state.board[i]).join('');
        updateTileVisuals();
        return;
      }

      // If touched tile is valid (adjacent and not selected), check if we should prefer a diagonal
      if (touchedIndex !== -1 && touchedIndex !== lastIndex &&
          !state.selectedPath.includes(touchedIndex) && areAdjacent(lastIndex, touchedIndex)) {

        const lastPos = getTileCenterPos(lastIndex);
        if (lastPos) {
          const dx = clientX - lastPos.x;
          const dy = clientY - lastPos.y;

          // Check if swiping diagonally
          const swipeAngle = Math.atan2(Math.abs(dy), Math.abs(dx));
          const isDiagonalSwipe = swipeAngle > 0.4 && swipeAngle < 1.17; // ~23¬∞ to ~67¬∞

          // If swiping diagonally but touched an orthogonal tile, look for a diagonal
          if (isDiagonalSwipe && !isDiagonal(lastIndex, touchedIndex)) {
            // Find diagonal tile in swipe direction
            for (let i = 0; i < 16; i++) {
              if (state.selectedPath.includes(i) || !areAdjacent(lastIndex, i) || !isDiagonal(lastIndex, i)) continue;

              const diagPos = getTileCenterPos(i);
              if (!diagPos) continue;

              const toDiagX = diagPos.x - lastPos.x;
              const toDiagY = diagPos.y - lastPos.y;

              // Check if diagonal is in our swipe direction
              if ((dx > 0) === (toDiagX > 0) && (dy > 0) === (toDiagY > 0)) {
                addTileToPath(i);
                return;
              }
            }
          }
        }

        // Add the touched tile
        addTileToPath(touchedIndex);
      }
    }

    // Add tile to path helper
    function addTileToPath(index) {
      if (!state.selectedPath.includes(index) && areAdjacent(state.selectedPath[state.selectedPath.length - 1], index)) {
        state.selectedPath.push(index);
        state.currentWord = state.selectedPath.map(i => state.board[i]).join('');
        updateTileVisuals();
      }
    }

    // Handle drag end
    function handleDragEnd(e) {
      if (!state.isDragging) return;
      state.isDragging = false;
      state.lastTouchTime = Date.now();
      // Clear pending tile
      clearTimeout(state.pendingTimeout);
      state.pendingTile = null;
      if (state.selectedPath.length > 0 && state.currentWord.length >= 3) {
        submitWord();
      } else {
        clearSelection();
      }
    }

    // Handle tile tap (for tap mode)
    function handleTileTap(index, e) {
      // Prevent ghost clicks after touch
      if (e.type === 'click' && Date.now() - state.lastTouchTime < 500) {
        e.preventDefault();
        return;
      }

      if (state.gameState !== 'playing' || state.inputMode !== 'tap') return;

      if (e.type === 'touchstart') {
        e.preventDefault();
        state.lastTouchTime = Date.now();
      }

      if (state.selectedPath.length === 0) {
        state.selectedPath = [index];
        state.currentWord = state.board[index];
      } else if (state.selectedPath.includes(index)) {
        if (state.selectedPath[state.selectedPath.length - 1] === index && state.selectedPath.length > 1) {
          state.selectedPath = state.selectedPath.slice(0, -1);
          state.currentWord = state.selectedPath.map(i => state.board[i]).join('');
        } else if (state.selectedPath.length === 1) {
          state.selectedPath = [];
          state.currentWord = '';
        }
      } else if (areAdjacent(state.selectedPath[state.selectedPath.length - 1], index)) {
        state.selectedPath.push(index);
        state.currentWord += state.board[index];
      }
      updateTileVisuals();
    }

    // Clear selection
    function clearSelection() {
      state.selectedPath = [];
      state.currentWord = '';
      render();
    }

    // Submit word
    function submitWord() {
      const word = state.inputMode === 'type' ? state.typedWord.toLowerCase() : state.currentWord.toLowerCase();
      
      if (word.length < 3) {
        showMessage('Words must be at least 3 letters');
        clearSelection();
        state.typedWord = '';
        render();
        return;
      }
      
      if (state.foundWords.includes(word)) {
        animateTiles([...state.selectedPath], 'tile-shake'); showMessage('Already found!');
        clearSelection();
        state.typedWord = '';
        render();
        return;
      }
      
      if (!DICTIONARY.has(word)) {
        animateTiles([...state.selectedPath], 'tile-shake');
        clearSelection();
        state.typedWord = '';
        render();
        return;
      }
      
      if (state.inputMode === 'type' && !canFormWord(word, state.board)) {
        showMessage('Cannot form on board');
        state.typedWord = '';
        render();
        return;
      }
      
      const wordScore = getWordScore(word);
      const pathCopy = [...state.selectedPath];
      const lastTile = getTileCenter(pathCopy[pathCopy.length - 1] || 0);

      state.foundWords.push(word);
      state.score += wordScore;

      // Quick visual updates
      showFloatingPoints(wordScore, lastTile.x - 20, lastTile.y - 20);
      animateTiles(pathCopy, 'tile-bounce');
      updateScoreDisplay();

      // Clear and update
      state.selectedPath = [];
      state.currentWord = '';
      state.typedWord = '';
      updateTileVisuals();

      // Full render to update found words list
      render();
    }

    // Quick score update without full render
    function updateScoreDisplay() {
      const scoreEl = document.getElementById('scoreDisplay');
      if (scoreEl) scoreEl.textContent = state.score + ' pts';
    }

    // Show message
    function showMessage(msg) {
      state.message = msg;
      // Update message element directly if it exists
      const msgEl = document.getElementById('messageDisplay');
      if (msgEl) {
        msgEl.innerHTML = msg ? `<span class="bg-white/20 text-white px-4 py-2 rounded-full font-medium">${msg}</span>` : '';
      } else {
        render();
      }
      // Always clear message after 1.5 seconds
      if (msg) {
        setTimeout(() => {
          state.message = '';
          const el = document.getElementById('messageDisplay');
          if (el) {
            el.innerHTML = '';
          }
        }, 1500);
      }
    }

    // Format time
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Share results
    function shareResults() {
      // Find longest word (count Qu as 1 letter)
      let longestWord = '';
      state.foundWords.forEach(word => {
        const len = word.replace(/qu/gi, 'Q').length;
        const longestLen = longestWord.replace(/qu/gi, 'Q').length;
        if (len > longestLen) longestWord = word;
      });
      const longestLen = longestWord ? longestWord.replace(/qu/gi, 'Q').length : 0;

      // Score emoji based on performance
      let scoreEmoji = 'üéØ';
      if (state.score >= 100) scoreEmoji = 'üèÜ';
      else if (state.score >= 50) scoreEmoji = 'üî•';
      else if (state.score >= 25) scoreEmoji = '‚≠ê';

      // Word length stars
      const stars = '‚¨õ'.repeat(Math.min(longestLen, 8));

      const shareText = `üé≤ Daily Boggle üé≤\nüìÖ ${state.todayDate}\n${scoreEmoji} ${state.score} points\nüìè Longest: ${longestLen} letters\n${stars}`;

      if (navigator.share) {
        navigator.share({ text: shareText }).catch(() => copyToClipboard(shareText));
      } else {
        copyToClipboard(shareText);
      }
    }

    // Copy to clipboard
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text);
      showMessage('Copied to clipboard!');
    }

    // Calculate all possible words on the board
    function getAllPossibleWords() {
      const possibleWords = [];
      DICTIONARY.forEach(word => {
        if (word.length >= 3 && canFormWord(word, state.board)) {
          possibleWords.push(word);
        }
      });
      return possibleWords;
    }

    // Login
    async function handleLogin() {
      const nameInput = document.getElementById('playerName');
      const name = nameInput.value.trim().toLowerCase();
      if (!name) return;

      state.playerName = name;
      localStorage.setItem('boggle_player', name);

      // Show loading state immediately
      const btn = document.querySelector('button[onclick="handleLogin()"]');
      if (btn) btn.textContent = 'Loading...';

      // Run API calls in parallel with timeout
      const timeout = (ms) => new Promise((_, reject) => setTimeout(() => reject('timeout'), ms));

      try {
        const [check, leaderboard] = await Promise.all([
          Promise.race([checkPlayer(name), timeout(3000)]).catch(() => ({ played: false })),
          Promise.race([getLeaderboard(), timeout(3000)]).catch(() => [])
        ]);

        state.leaderboard = leaderboard;

        if (check.played) {
          state.score = check.score;
          state.foundWords = [];
          state.gameState = 'finished';
          showMessage("You've already played today!");
        } else {
          state.gameState = 'ready';
        }
      } catch (e) {
        // If API fails, just let them play
        state.gameState = 'ready';
      }

      render();
    }

    // Start game
    function startGame() {
      // In practice mode, check if a code was entered and load that board
      if (state.practiceMode) {
        const codeInput = document.getElementById('practiceCodeInput');
        if (codeInput && codeInput.value.trim()) {
          const code = parseInt(codeInput.value.trim());
          if (code >= 10000 && code <= 99999) {
            state.practiceCode = code;
            state.board = generateSeededBoard(code);
          }
        }
      }

      state.gameState = 'playing';
      state.foundWords = [];
      state.score = 0;
      state.timeLeft = 180;
      state.message = '';
      state.possibleWords = null;

      // Track actual end time so timer works even when tab is backgrounded
      const endTime = Date.now() + 180 * 1000;

      state.timerInterval = setInterval(() => {
        const remaining = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
        state.timeLeft = remaining;

        if (remaining <= 0) {
          endGame();
        } else {
          // Quick timer update without full render
          const timerEl = document.getElementById('timerDisplay');
          if (timerEl) {
            timerEl.textContent = '‚è± ' + formatTime(remaining);
            timerEl.className = 'text-2xl font-mono font-bold ' + (remaining <= 30 ? 'text-red-300 timer-urgent' : 'text-white');
          }
        }
      }, 1000);

      render();
    }

    // Start practice mode
    function startPracticeMode() {
      const nameInput = document.getElementById('playerName');
      const name = nameInput ? nameInput.value.trim().toLowerCase() : 'player';
      state.playerName = name || 'player';
      state.practiceMode = true;
      state.board = generateRandomBoard();
      state.gameState = 'ready';
      state.leaderboard = [];
      render();
    }

    // ============================================
    // MULTIPLAYER FUNCTIONS
    // ============================================

    function showMultiplayerMenu() {
      const nameInput = document.getElementById('playerName');
      const name = nameInput ? nameInput.value.trim().toLowerCase() : '';
      if (!name) {
        showMessage('Enter your name first');
        return;
      }
      state.playerName = name;
      localStorage.setItem('boggle_player', name);
      state.gameState = 'mp-menu';
      render();
    }

    async function hostGame() {
      const boardCode = generatePracticeCode();
      state.practiceCode = boardCode;
      state.board = generateSeededBoard(boardCode);

      showMessage('Creating room...');
      const result = await mpCreateRoom(state.playerName, boardCode);

      if (result.error) {
        showMessage(result.error);
        return;
      }

      state.multiplayerMode = true;
      state.roomId = result.roomId;
      state.isHost = true;
      state.roomPlayers = [state.playerName];
      state.roomStatus = 'waiting';
      state.gameState = 'mp-lobby';

      // Start polling for players
      startLobbyPolling();
      render();
    }

    async function joinGame() {
      const codeInput = document.getElementById('roomCodeInput');
      const roomId = codeInput ? codeInput.value.trim() : '';

      if (!roomId || roomId.length !== 5 || !/^\d{5}$/.test(roomId)) {
        showMessage('Enter a 5-digit room code');
        return;
      }

      const result = await mpJoinRoom(roomId, state.playerName);

      if (result.error) {
        showMessage(result.error);
        return;
      }

      state.multiplayerMode = true;
      state.roomId = roomId;
      state.isHost = false;
      state.roomPlayers = result.players;
      state.practiceCode = result.boardCode;
      state.board = generateSeededBoard(result.boardCode);
      state.roomStatus = 'waiting';
      state.gameState = 'mp-lobby';

      // Start polling
      startLobbyPolling();
      render();
    }

    function startLobbyPolling() {
      if (state.pollInterval) clearInterval(state.pollInterval);

      state.pollInterval = setInterval(async () => {
        const result = await mpPollRoom(state.roomId);

        if (result.error) {
          console.error('Poll error:', result.error);
          return;
        }

        // Check if players changed before updating
        const playersChanged = JSON.stringify(state.roomPlayers) !== JSON.stringify(result.players);
        state.roomPlayers = result.players;
        state.roomStatus = result.status;

        // If game started, transition to playing
        if (result.status === 'playing' && state.gameState === 'mp-lobby') {
          state.mpStartTime = result.startTime;
          stopPolling();
          startMultiplayerGame(result.startTime);
          return;
        }

        // If game finished, get results
        if (result.status === 'finished' && state.gameState !== 'mp-results') {
          stopPolling();
          await fetchResults();
          return;
        }

        // Only re-render if players changed, otherwise just update the list
        if (playersChanged) {
          const playersList = document.getElementById('playersList');
          const playerCount = document.getElementById('playerCount');
          if (playersList && playerCount) {
            playerCount.textContent = result.players.length;
            playersList.innerHTML = result.players.map((p, i) =>
              `<div class="flex items-center justify-center gap-2 text-white">
                <span class="w-2 h-2 bg-green-400 rounded-full"></span>
                <span>${p}${i === 0 ? ' (host)' : ''}</span>
              </div>`
            ).join('');
          } else {
            render();
          }
        }
      }, 1500);
    }

    function stopPolling() {
      if (state.pollInterval) {
        clearInterval(state.pollInterval);
        state.pollInterval = null;
      }
    }

    async function mpHostStartGame() {
      // Stop polling immediately to prevent re-renders
      stopPolling();
      state.roomStatus = 'starting';
      render();

      const result = await mpStartRoom(state.roomId);

      if (result.error) {
        showMessage(result.error);
        state.roomStatus = 'waiting';
        startLobbyPolling();
        return;
      }

      state.mpStartTime = result.startTime;
      startMultiplayerGame(result.startTime);
    }

    function startMultiplayerGame(startTime) {
      // Prevent multiple countdowns
      if (state.gameState === 'mp-countdown' || state.gameState === 'playing') return;

      // Clear any existing countdown
      if (state.countdownInterval) {
        clearInterval(state.countdownInterval);
        state.countdownInterval = null;
      }

      // Validate startTime
      if (!startTime || typeof startTime !== 'number') {
        console.error('Invalid startTime:', startTime);
        beginMultiplayerPlay();
        return;
      }

      // If startTime already passed, start immediately
      const initialRemaining = Math.ceil((startTime - Date.now()) / 1000);
      if (initialRemaining <= 0) {
        beginMultiplayerPlay();
        return;
      }

      state.gameState = 'mp-countdown';
      render();

      // Update initial display
      const countdownEl = document.getElementById('countdownDisplay');
      if (countdownEl) countdownEl.textContent = initialRemaining;

      state.countdownInterval = setInterval(() => {
        const remaining = Math.ceil((startTime - Date.now()) / 1000);

        if (remaining <= 0) {
          clearInterval(state.countdownInterval);
          state.countdownInterval = null;
          beginMultiplayerPlay();
        } else {
          // Update countdown display
          const el = document.getElementById('countdownDisplay');
          if (el) el.textContent = remaining;
        }
      }, 250);
    }

    function beginMultiplayerPlay() {
      state.gameState = 'playing';
      state.foundWords = [];
      state.score = 0;
      state.timeLeft = 180;
      state.message = '';
      state.possibleWords = null;

      const endTime = Date.now() + 180 * 1000;

      state.timerInterval = setInterval(() => {
        const remaining = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
        state.timeLeft = remaining;

        if (remaining <= 0) {
          endMultiplayerGame();
        } else {
          const timerEl = document.getElementById('timerDisplay');
          if (timerEl) {
            timerEl.textContent = '‚è± ' + formatTime(remaining);
            timerEl.className = 'text-2xl font-mono font-bold ' + (remaining <= 30 ? 'text-red-300 timer-urgent' : 'text-white');
          }
        }
      }, 1000);

      render();
    }

    async function endMultiplayerGame() {
      clearInterval(state.timerInterval);
      state.gameState = 'mp-waiting';
      state.mpSubmitted = false;
      clearSelection();

      if (navigator.vibrate) navigator.vibrate([100, 50, 100]);

      render();

      // Submit words to server
      showMessage('Submitting words...');
      const submitResult = await mpSubmitWords(state.roomId, state.playerName, state.foundWords);

      // Mark as submitted and re-render to show button
      state.mpSubmitted = true;

      if (submitResult.error) {
        showMessage('Error submitting words. Retrying...');
        // Retry once
        await mpSubmitWords(state.roomId, state.playerName, state.foundWords);
      }

      render();

      // Start polling for results
      startResultsPolling();
    }

    function startResultsPolling() {
      const startedWaiting = Date.now();
      const TIMEOUT = 15000; // 15 second timeout

      state.pollInterval = setInterval(async () => {
        const result = await mpPollRoom(state.roomId);

        // Check for timeout - force results after 15 seconds
        if (Date.now() - startedWaiting > TIMEOUT) {
          stopPolling();
          await fetchResults();
          return;
        }

        if (result.status === 'finished') {
          stopPolling();
          await fetchResults();
        } else {
          // Update who has submitted
          const waitingEl = document.getElementById('waitingStatus');
          if (waitingEl) {
            const submitted = result.playersSubmitted ? result.playersSubmitted.length : 0;
            const total = result.players ? result.players.length : 0;
            waitingEl.textContent = `${submitted}/${total} players finished`;
          }
        }
      }, 1000);
    }

    function forceResults() {
      stopPolling();
      fetchResults();
    }

    async function fetchResults() {
      const result = await mpGetResults(state.roomId);

      if (result.error) {
        showMessage(result.error);
        return;
      }

      state.mpResults = result;
      state.gameState = 'mp-results';
      render();
    }

    function leaveRoom() {
      stopPolling();
      mpLeaveRoom(state.roomId, state.playerName);
      resetMultiplayerState();
      state.gameState = 'login';
      render();
    }

    function resetMultiplayerState() {
      state.multiplayerMode = false;
      state.roomId = null;
      state.isHost = false;
      state.roomPlayers = [];
      state.roomStatus = null;
      state.mpResults = null;
      state.mpStartTime = null;
      state.mpSubmitted = false;
      if (state.countdownInterval) {
        clearInterval(state.countdownInterval);
        state.countdownInterval = null;
      }
      stopPolling();
    }

    function copyRoomCode() {
      if (state.roomId) {
        navigator.clipboard.writeText(state.roomId);
        showMessage('Room code copied!');
      }
    }

    function mpPlayAgain() {
      // Host creates new room, others will need to rejoin
      resetMultiplayerState();
      hostGame();
    }

    function mpExit() {
      leaveRoom();
    }

    // Load board from code
    function loadBoardFromCode() {
      const codeInput = document.getElementById('practiceCodeInput');
      const code = parseInt(codeInput.value.trim());
      if (code >= 10000 && code <= 99999) {
        state.practiceCode = code;
        state.board = generateSeededBoard(code);
        state.possibleWords = null;
        render();
      } else {
        showMessage('Enter a 5-digit code');
      }
    }

    // Copy practice code
    function copyPracticeCode() {
      if (state.practiceCode) {
        navigator.clipboard.writeText(state.practiceCode.toString());
        showMessage('Code copied!');
      }
    }

    // New game - go back to ready screen to enter codes (practice mode)
    function newGame() {
      state.board = generateRandomBoard();
      state.possibleWords = null;
      state.foundWords = [];
      state.score = 0;
      state.gameState = 'ready';
      render();
    }

    // Replay same board (practice mode)
    function replayBoard() {
      state.possibleWords = null;
      startGame();
    }

    // Back to main menu
    function backToMenu() {
      state.gameState = 'login';
      state.practiceMode = false;
      state.foundWords = [];
      state.score = 0;
      state.possibleWords = null;
      state.board = generateDailyBoard(state.todayDate);
      render();
    }

    // Remove word and recalculate score (practice mode)
    function removeWord(word) {
      const index = state.foundWords.indexOf(word);
      if (index > -1) {
        state.foundWords.splice(index, 1);
        state.score = state.foundWords.reduce((total, w) => total + getWordScore(w), 0);
        render();
      }
    }

    // End game
    async function endGame() {
      clearInterval(state.timerInterval);
      state.gameState = 'finished';
      clearSelection();

      // Haptic vibration on game end (Android only - iOS doesn't support Vibration API)
      if (navigator.vibrate) navigator.vibrate([100, 50, 100]);

      // Render finished state immediately, don't wait for API
      render();

      // Calculate possible words in background
      setTimeout(() => {
        state.possibleWords = getAllPossibleWords();
        render();
      }, 100);

      // Skip saving score in practice mode
      if (state.practiceMode) return;

      // Save score and get leaderboard in background
      try {
        await saveScore(state.playerName, state.score, state.foundWords.length);
        state.leaderboard = await getLeaderboard();
        render(); // Re-render with leaderboard
      } catch (e) {
        console.error('Error saving score:', e);
      }
    }

    // Set input mode
    function setInputMode(mode) {
      state.inputMode = mode;
      state.typedWord = '';
      clearSelection();
    }

    // Render
    function render() {
      const app = document.getElementById('app');
      
      // Login screen
      if (state.gameState === 'login') {
        app.innerHTML = `
          <div class="min-h-screen flex items-center justify-center p-4">
            <div class="bg-white/10 backdrop-blur rounded-2xl p-8 max-w-sm w-full text-center">
              <h1 class="text-3xl font-bold text-white mb-2">Daily Boggle</h1>
              <p class="text-blue-100 mb-6">${state.todayDate}</p>
              <input 
                type="text" 
                id="playerName" 
                placeholder="Enter your name"
                value="${state.playerName}"
                class="w-full px-4 py-3 rounded-xl text-lg text-center outline-none mb-4"
                onkeypress="if(event.key==='Enter')handleLogin()"
              />
              <button
                onclick="handleLogin()"
                class="w-full px-6 py-3 bg-green-500 hover:bg-green-400 rounded-xl text-white text-lg font-bold transition-colors"
              >
                Play
              </button>
              <button
                onclick="startPracticeMode()"
                class="w-full px-6 py-3 mt-3 bg-white/20 hover:bg-white/30 rounded-xl text-white text-lg font-bold transition-colors"
              >
                Practice Mode
              </button>
              <button
                onclick="showMultiplayerMenu()"
                class="w-full px-6 py-3 mt-3 bg-purple-500 hover:bg-purple-400 rounded-xl text-white text-lg font-bold transition-colors"
              >
                Multiplayer
              </button>
            </div>
          </div>
        `;
        return;
      }

      // Multiplayer Menu
      if (state.gameState === 'mp-menu') {
        app.innerHTML = `
          <div class="min-h-screen flex items-center justify-center p-4">
            <div class="bg-white/10 backdrop-blur rounded-2xl p-8 max-w-sm w-full text-center">
              <h1 class="text-3xl font-bold text-white mb-2">Multiplayer</h1>
              <p class="text-blue-100 mb-6">Playing as ${state.playerName}</p>
              <button
                onclick="hostGame()"
                class="w-full px-6 py-3 bg-green-500 hover:bg-green-400 rounded-xl text-white text-lg font-bold transition-colors"
              >
                Host Game
              </button>
              <div class="my-4 text-white/50">‚Äî or ‚Äî</div>
              <input
                type="text"
                id="roomCodeInput"
                placeholder="Enter room code"
                maxlength="5"
                inputmode="numeric"
                pattern="[0-9]*"
                class="w-full px-4 py-3 rounded-xl text-lg text-center outline-none mb-3 font-mono"
                onkeypress="if(event.key==='Enter')joinGame()"
              />
              <button
                onclick="joinGame()"
                class="w-full px-6 py-3 bg-blue-500 hover:bg-blue-400 rounded-xl text-white text-lg font-bold transition-colors"
              >
                Join Game
              </button>
              <button
                onclick="state.gameState='login'; render();"
                class="w-full px-6 py-3 mt-4 bg-white/20 hover:bg-white/30 rounded-xl text-white text-lg font-bold transition-colors"
              >
                ‚Üê Back
              </button>
            </div>
          </div>
        `;
        return;
      }

      // Multiplayer Lobby
      if (state.gameState === 'mp-lobby') {
        app.innerHTML = `
          <div class="min-h-screen flex items-center justify-center p-4">
            <div class="bg-white/10 backdrop-blur rounded-2xl p-8 max-w-sm w-full text-center">
              <h1 class="text-3xl font-bold text-white mb-2">Game Lobby</h1>
              <div class="mb-4">
                <p class="text-white/70 text-sm mb-1">Room Code</p>
                <div class="flex justify-center items-center gap-2">
                  <span class="text-4xl font-mono font-bold text-yellow-300 tracking-wider">${state.roomId}</span>
                  <button onclick="copyRoomCode()" class="px-3 py-1 bg-white/20 hover:bg-white/30 rounded-lg text-white text-sm transition-colors">Copy</button>
                </div>
              </div>
              <div class="bg-white/10 rounded-xl p-4 mb-4">
                <p class="text-white/70 text-sm mb-2">Players (<span id="playerCount">${state.roomPlayers.length}</span>)</p>
                <div id="playersList" class="space-y-2">
                  ${state.roomPlayers.map((p, i) => `
                    <div class="flex items-center justify-center gap-2 text-white">
                      <span class="w-2 h-2 bg-green-400 rounded-full"></span>
                      <span>${p}${i === 0 ? ' (host)' : ''}</span>
                    </div>
                  `).join('')}
                </div>
              </div>
              ${state.roomStatus === 'starting' ? `
                <div class="w-full px-6 py-3 bg-yellow-500 rounded-xl text-white text-lg font-bold mb-3 animate-pulse">
                  Starting...
                </div>
              ` : state.isHost ? `
                <button
                  onclick="mpHostStartGame()"
                  class="w-full px-6 py-3 bg-green-500 hover:bg-green-400 rounded-xl text-white text-lg font-bold transition-colors mb-3"
                  ${state.roomPlayers.length < 2 ? 'disabled style="opacity:0.5;cursor:not-allowed"' : ''}
                >
                  Start Game
                </button>
                ${state.roomPlayers.length < 2 ? '<p class="text-white/50 text-sm mb-3">Waiting for players to join...</p>' : ''}
              ` : `
                <p class="text-white/70 mb-4">Waiting for host to start...</p>
              `}
              <button
                onclick="leaveRoom()"
                class="w-full px-6 py-3 bg-white/20 hover:bg-white/30 rounded-xl text-white text-lg font-bold transition-colors"
              >
                Leave
              </button>
            </div>
          </div>
        `;
        return;
      }

      // Multiplayer Countdown
      if (state.gameState === 'mp-countdown') {
        app.innerHTML = `
          <div class="min-h-screen flex items-center justify-center p-4">
            <div class="text-center">
              <p class="text-white text-2xl mb-4">Game starting in...</p>
              <div id="countdownDisplay" class="text-8xl font-bold text-yellow-300">5</div>
            </div>
          </div>
        `;
        return;
      }

      // Multiplayer Waiting for Results
      if (state.gameState === 'mp-waiting') {
        app.innerHTML = `
          <div class="min-h-screen flex items-center justify-center p-4">
            <div class="bg-white/10 backdrop-blur rounded-2xl p-8 max-w-sm w-full text-center">
              <h1 class="text-2xl font-bold text-white mb-4">Time's Up!</h1>
              <p class="text-white mb-2">Your score: <span class="text-yellow-300 font-bold">${state.score} pts</span></p>
              <p class="text-white mb-4">${state.foundWords.length} words found</p>
              <div class="animate-pulse mb-4">
                <p id="waitingStatus" class="text-white/70">${state.mpSubmitted ? 'Waiting for other players...' : 'Submitting your words...'}</p>
              </div>
              ${state.mpSubmitted ? `
                <button onclick="forceResults()" class="px-6 py-2 bg-white/20 hover:bg-white/30 rounded-xl text-white font-bold transition-colors text-sm">
                  View Results Anyway
                </button>
              ` : ''}
            </div>
          </div>
        `;
        return;
      }

      // Multiplayer Results
      if (state.gameState === 'mp-results') {
        const results = state.mpResults;
        const myResult = results.players.find(p => p.name.toLowerCase() === state.playerName.toLowerCase());

        app.innerHTML = `
          <div class="max-w-md mx-auto p-4">
            <div class="text-center mb-4">
              <h1 class="text-3xl font-bold text-white mb-1">Results</h1>
              <p class="text-blue-100 text-sm">Room ${state.roomId}</p>
            </div>

            <div class="bg-white/10 backdrop-blur rounded-2xl p-4 mb-4">
              <h2 class="text-white font-bold mb-3 text-center">Final Scores</h2>
              <div class="space-y-2">
                ${results.players.map((p, i) => {
                  const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
                  const isMe = p.name === state.playerName;
                  return `
                    <div class="flex justify-between items-center ${isMe ? 'bg-white/20 rounded-lg px-3 py-2' : 'px-3 py-1'}">
                      <span class="text-white">${medal} ${p.name}${isMe ? ' (you)' : ''}</span>
                      <span class="text-yellow-300 font-bold">${p.score} pts</span>
                    </div>
                  `;
                }).join('')}
              </div>
            </div>

            ${myResult ? `
              <div class="bg-white/10 backdrop-blur rounded-2xl p-4 mb-4">
                <h3 class="text-white font-bold mb-2">Your Words (${myResult.words.length})</h3>
                <div class="flex flex-wrap gap-2">
                  ${myResult.words.sort().map(word => {
                    const isDuplicate = results.duplicates.includes(word);
                    return isDuplicate
                      ? `<span class="bg-red-500/30 text-red-200 px-2 py-1 rounded text-sm line-through">${word.toUpperCase()}</span>`
                      : `<span class="bg-green-500/30 text-green-200 px-2 py-1 rounded text-sm">${word.toUpperCase()} +${getWordScore(word)}</span>`;
                  }).join('')}
                </div>
                ${results.duplicates.length > 0 ? `
                  <p class="text-white/50 text-xs mt-2">Crossed out words were found by multiple players</p>
                ` : ''}
              </div>
            ` : ''}

            <div class="flex gap-2">
              ${state.isHost ? `
                <button onclick="mpPlayAgain()" class="flex-1 px-6 py-3 bg-green-500 hover:bg-green-400 rounded-xl text-white font-bold transition-colors">
                  New Game
                </button>
              ` : ''}
              <button onclick="mpExit()" class="flex-1 px-6 py-3 bg-white/20 hover:bg-white/30 rounded-xl text-white font-bold transition-colors">
                Exit
              </button>
            </div>
          </div>
        `;
        return;
      }

      let html = `<div class="max-w-md mx-auto p-4">`;
      
      // Header
      const title = state.multiplayerMode ? 'Multiplayer' : (state.practiceMode ? 'Practice Mode' : 'Daily Boggle');
      const subtitle = state.multiplayerMode ? `Room ${state.roomId} ‚Ä¢ ${state.playerName}` : (state.practiceMode ? state.playerName : `${state.todayDate} ‚Ä¢ ${state.playerName}`);
      html += `
        <div class="text-center mb-4">
          <h1 class="text-3xl font-bold text-white mb-1">${title}</h1>
          <p class="text-blue-100 text-sm">${subtitle}</p>
        </div>
      `;
      
      // Timer and Score (playing)
      if (state.gameState === 'playing') {
        html += `
          <div class="flex justify-between items-center mb-4 px-2">
            <div id="timerDisplay" class="text-2xl font-mono font-bold ${state.timeLeft <= 30 ? 'text-red-300 timer-urgent' : 'text-white'}">
              ‚è± ${formatTime(state.timeLeft)}
            </div>
            <div id="scoreDisplay" class="text-2xl font-bold text-yellow-300">${state.score} pts</div>
          </div>
        `;
      }

      // Game Board (only show during playing and finished)
      if (state.gameState === 'playing' || state.gameState === 'finished') {
        html += `<div class="bg-white/10 backdrop-blur rounded-2xl p-4 mb-4 select-none board-container"><svg class="swipe-svg" id="swipeSvg"></svg><div class="grid grid-cols-4 gap-2">`;

        state.board.forEach((letter, index) => {
          const isSelected = state.selectedPath.includes(index);
          const isLast = state.selectedPath[state.selectedPath.length - 1] === index;

          let tileClass = 'aspect-square rounded-xl text-2xl font-bold transition-all duration-100 select-none tile ';
          if (isSelected) {
            tileClass += isLast ? 'bg-yellow-400 text-green-900 scale-110 shadow-lg ring-4 ring-yellow-300' : 'bg-teal-400 text-white';
          } else {
            tileClass += 'bg-white text-green-800';
          }
          if (state.gameState !== 'playing') tileClass += ' opacity-75';

          html += `<button class="${tileClass}" data-index="${index}">${letter}</button>`;
        });

        html += `</div></div>`;
      }
      
      // Input area (playing)
      if (state.gameState === 'playing') {
        html += `
          <div class="mb-4">
            <div class="flex justify-center gap-2 mb-3">
              <button onclick="setInputMode('swipe')" class="px-4 py-1 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'swipe' ? 'bg-white text-green-800' : 'bg-white/20 text-white'}">Swipe</button>
              <button onclick="setInputMode('tap')" class="px-4 py-1 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'tap' ? 'bg-white text-green-800' : 'bg-white/20 text-white'}">Tap</button>
              <button onclick="setInputMode('type')" class="px-4 py-1 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'type' ? 'bg-white text-green-800' : 'bg-white/20 text-white'}">Type</button>
            </div>
        `;
        
        if (state.inputMode === 'type') {
          html += `
            <div class="flex gap-2">
              <input type="text" id="typeInput" value="${state.typedWord}" placeholder="Type a word..." 
                class="flex-1 bg-white/20 rounded-xl px-4 py-3 text-white text-xl font-bold placeholder-white/50 outline-none focus:bg-white/30"
                autocomplete="off" autocapitalize="off" />
              <button onclick="submitWord()" class="px-6 bg-green-500 hover:bg-green-400 disabled:bg-gray-500 disabled:opacity-50 rounded-xl text-white font-bold transition-colors">‚úì</button>
            </div>
          `;
        } else {
          html += `
            <div class="flex gap-2">
              <div class="flex-1 bg-white/20 rounded-xl px-4 py-3 text-center min-h-[52px] flex items-center justify-center">
                <span id="currentWordDisplay" class="text-2xl font-bold text-white tracking-wider">${state.currentWord || (state.inputMode === 'swipe' ? 'Swipe letters...' : 'Tap letters...')}</span>
              </div>
              ${state.inputMode === 'tap' ? `
                <button onclick="submitWord()" class="px-6 bg-green-500 hover:bg-green-400 rounded-xl text-white font-bold transition-colors">‚úì</button>
                <button onclick="clearSelection()" class="px-4 bg-red-500 hover:bg-red-400 rounded-xl text-white font-bold transition-colors">‚úï</button>
              ` : ''}
            </div>
          `;
        }
        html += `</div>`;
      }
      
      // Message (always render container for quick updates)
      html += `<div id="messageDisplay" class="text-center mb-4">${state.message ? `<span class="bg-white/20 text-white px-4 py-2 rounded-full font-medium">${state.message}</span>` : ''}</div>`;
      
      // Ready state
      if (state.gameState === 'ready') {
        html += `
          <div class="bg-white/10 backdrop-blur rounded-2xl p-6 mb-4">
            <p class="text-green-100 text-center mb-6">Find as many words as you can in 3 minutes!<br/>Select adjacent letters to form words.</p>

            ${state.practiceMode ? `
            <div class="mb-6 text-center">
              <p class="text-white/70 text-sm mb-2">Board Code</p>
              <div class="flex justify-center items-center gap-2 mb-3">
                <span class="text-3xl font-mono font-bold text-yellow-300 tracking-wider">${state.practiceCode}</span>
                <button onclick="copyPracticeCode()" class="px-3 py-1 bg-white/20 hover:bg-white/30 rounded-lg text-white text-sm transition-colors">Copy</button>
              </div>
              <p class="text-white/50 text-xs mb-3">Share this code so others get the same board</p>
              <div class="flex justify-center items-center gap-2">
                <input type="text" id="practiceCodeInput" placeholder="Enter code" maxlength="5"
                  class="w-28 px-3 py-2 rounded-lg text-center font-mono text-lg outline-none" />
                <button onclick="state.board = generateRandomBoard(); render();" class="px-3 py-2 bg-white/20 hover:bg-white/30 rounded-lg text-white text-sm transition-colors">New</button>
              </div>
            </div>
            ` : ''}

            <div class="mb-6">
              <p class="text-white/70 text-sm text-center mb-3">Input Method</p>
              <div class="flex justify-center gap-2">
                <button onclick="setInputMode('swipe')" class="px-5 py-2 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'swipe' ? 'bg-white text-green-800' : 'bg-white/20 text-white hover:bg-white/30'}">Swipe</button>
                <button onclick="setInputMode('tap')" class="px-5 py-2 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'tap' ? 'bg-white text-green-800' : 'bg-white/20 text-white hover:bg-white/30'}">Tap</button>
                <button onclick="setInputMode('type')" class="px-5 py-2 rounded-full text-sm font-medium transition-colors ${state.inputMode === 'type' ? 'bg-white text-green-800' : 'bg-white/20 text-white hover:bg-white/30'}">Type</button>
              </div>
            </div>

            <div class="text-center">
              <button onclick="startGame()" class="px-8 py-4 bg-green-500 hover:bg-green-400 rounded-2xl text-white text-xl font-bold transition-colors shadow-lg">Start Game</button>
            </div>
          </div>
        `;
      }
      
      // Finished state
      if (state.gameState === 'finished') {
        const possibleCount = state.possibleWords ? state.possibleWords.length : null;
        const percentFound = possibleCount ? Math.round((state.foundWords.length / possibleCount) * 100) : null;

        // Score message
        let scoreMessage = '';
        if (state.score <= 10) scoreMessage = 'Words may not be your thing!';
        else if (state.score <= 15) scoreMessage = 'Not bad!';
        else if (state.score <= 20) scoreMessage = 'Good job!';
        else scoreMessage = 'You did really good!';

        html += `
          <div class="text-center">
            <div class="bg-white/10 backdrop-blur rounded-2xl p-6 mb-4">
              <h2 class="text-xl font-bold text-white mb-2">${state.foundWords.length > 0 ? "Time's Up!" : "Today's Results"}</h2>
              <div class="text-4xl font-bold text-yellow-300 mb-2">${state.score} pts</div>
              <p class="text-white text-lg mb-1">${scoreMessage}</p>
              <p class="text-green-100">${state.foundWords.length} words found</p>
              <p class="text-green-200 text-sm mt-2">
                ${possibleCount !== null
                  ? `üìä ${possibleCount} possible words (you found ${percentFound}%)`
                  : 'üìä Calculating possible words...'}
              </p>
            </div>
            <div class="flex flex-wrap justify-center gap-2 mb-4">
              <button onclick="shareResults()" class="px-6 py-3 bg-blue-500 hover:bg-blue-400 rounded-xl text-white font-bold transition-colors">Share</button>
              ${state.practiceMode ? `
                <button onclick="newGame()" class="px-6 py-3 bg-green-500 hover:bg-green-400 rounded-xl text-white font-bold transition-colors">New Game</button>
                <button onclick="replayBoard()" class="px-6 py-3 bg-white/20 hover:bg-white/30 rounded-xl text-white font-bold transition-colors">Replay</button>
              ` : ''}
              <button onclick="backToMenu()" class="px-6 py-3 bg-white/20 hover:bg-white/30 rounded-xl text-white font-bold transition-colors">Menu</button>
            </div>
        `;
        
        // Leaderboard
        if (state.leaderboard.length > 0) {
          html += `
            <div class="bg-white/10 backdrop-blur rounded-2xl p-4 mt-4">
              <h3 class="text-white font-bold mb-2">Today's Leaderboard</h3>
              <div class="space-y-2">
          `;
          state.leaderboard.forEach((entry, i) => {
            const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
            html += `<div class="flex justify-between text-white"><span>${medal} ${entry.player}</span><span class="text-yellow-300">${entry.score} pts</span></div>`;
          });
          html += `</div></div>`;
        }
        
        html += `</div>`;
      }
      
      // Found words
      if (state.foundWords.length > 0) {
        const canRemove = state.practiceMode && state.gameState === 'finished';
        // Sort alphabetically in practice mode finished state, by score otherwise
        const sorted = canRemove
          ? [...state.foundWords].sort((a, b) => a.localeCompare(b))
          : [...state.foundWords].sort((a, b) => getWordScore(b) - getWordScore(a));
        html += `
          <div class="mt-4 bg-white/10 backdrop-blur rounded-2xl p-4">
            <h3 class="text-white font-bold mb-2">Found Words (${state.foundWords.length})${canRemove ? ' <span class="font-normal text-white/50 text-sm">- tap to remove</span>' : ''}</h3>
            <div class="flex flex-wrap gap-2">
              ${sorted.map(word => canRemove
                ? `<button onclick="removeWord('${word}')" class="bg-white/20 hover:bg-red-500/50 text-white px-2 py-1 rounded text-sm transition-colors">${word.toUpperCase()} <span class="text-yellow-300">+${getWordScore(word)}</span> <span class="text-red-300 ml-1">‚úï</span></button>`
                : `<span class="bg-white/20 text-white px-2 py-1 rounded text-sm">${word.toUpperCase()} <span class="text-yellow-300">+${getWordScore(word)}</span></span>`
              ).join('')}
            </div>
          </div>
        `;
      }
      
      // Scoring guide
      html += `<div class="mt-4 text-center text-green-200 text-xs"><p>3-4 letters: 1pt ‚Ä¢ 5: 2pts ‚Ä¢ 6: 3pts ‚Ä¢ 7: 5pts ‚Ä¢ 8+: 11pts</p></div>`;
      
      html += `</div>`;
      app.innerHTML = html;
      
      // Attach event listeners to tiles
      tileElements = Array.from(document.querySelectorAll('[data-index]'));
      tileElements.forEach(tile => {
        const index = parseInt(tile.dataset.index);
        // Swipe mode handlers
        tile.addEventListener('mousedown', (e) => handleDragStart(index, e));
        tile.addEventListener('touchstart', (e) => {
          if (state.inputMode === 'swipe') {
            handleDragStart(index, e);
          } else if (state.inputMode === 'tap') {
            handleTileTap(index, e);
          }
        }, { passive: false });
        // Click handler for tap mode (desktop)
        tile.addEventListener('click', (e) => handleTileTap(index, e));
      });
      
      // Type input listener
      const typeInput = document.getElementById('typeInput');
      if (typeInput) {
        typeInput.addEventListener('input', (e) => {
          state.typedWord = e.target.value.toLowerCase();
        });
        typeInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') submitWord();
        });
        typeInput.focus();
      }

      // Draw swipe lines after DOM is ready
      setTimeout(() => updateSwipeLines(), 0);
    }

    // Global event listeners
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
    document.addEventListener('mouseleave', handleDragEnd);
    document.addEventListener('touchmove', handleDragMove, { passive: false });
    document.addEventListener('touchend', handleDragEnd);
    document.addEventListener('touchcancel', handleDragEnd);

    // Make functions global
    window.handleLogin = handleLogin;
    window.startGame = startGame;
    window.startPracticeMode = startPracticeMode;
    window.newGame = newGame;
    window.backToMenu = backToMenu;
    window.submitWord = submitWord;
    window.clearSelection = clearSelection;
    window.setInputMode = setInputMode;
    window.shareResults = shareResults;
    window.loadBoardFromCode = loadBoardFromCode;
    window.copyPracticeCode = copyPracticeCode;
    window.generateRandomBoard = generateRandomBoard;
    window.replayBoard = replayBoard;
    window.removeWord = removeWord;
    // Multiplayer
    window.showMultiplayerMenu = showMultiplayerMenu;
    window.hostGame = hostGame;
    window.joinGame = joinGame;
    window.mpHostStartGame = mpHostStartGame;
    window.leaveRoom = leaveRoom;
    window.copyRoomCode = copyRoomCode;
    window.mpPlayAgain = mpPlayAgain;
    window.mpExit = mpExit;
    window.forceResults = forceResults;

    // Initial render
    render();
  </script>
</body>
</html>
